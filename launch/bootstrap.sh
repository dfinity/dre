#!/usr/bin/env bash

# This is the bootstrap script, used to deploy replicas from scratch at launch.
#
# Roughly speaking, this script:
# 1. sets up a dfinity-owned nns
# 2. registers x independent nodes to extend the root nns (This extended nns is called the "parent_nns")
# 3. registers y independent nodes to create a child_nns, with keys generated by all nodes in the parent_nns.  (A single honest parent node is enough to make the key generation of the child nns unguessable).
# 4. installs nns canisters on child nns
# 5. registers z independent nodes to create an application subnet.  This step may be repeated as often as required
# 6. adds monitoring for all the nodes on teh network.
#
# Prerequisites
# env/$NETWORK/hosts must be formatted like env/bootstrap/hosts,
# with at least two subnets and provisional white list
#
# env/$NETWORK/parent_hosts must be formatted like env/bootstrap/parent_hosts,
# with two subnets and a dummy provisional white list

# Shellcheck exemption:
# We use subshells to isolate code.  Shellcheck is concerned that changes ae meant to be global.
# shellcheck disable=SC2030,SC2031,SC2154
# We use sed a lot, but shellcheck is worried about '$' not expanding to  avaraible.
# shellcheck disable=SC2016
: End shellcheck global rules

set -euo pipefail

results_dir="${OUTPUT_DIR:-$TMPDIR/bootstrap}"

while (($# > 0)); do
    case "$1" in
        -h | --help)
            # Note: The text must be indented with tabs for an indented heredoc.
            cat <<-EOF


			Bootstraps a testnnet.

			Usage:  $0 [flags] <testnet_identifier> <results_dir>

			Flags:

			    -d|--dry-run = Print the steps but do not execute them. (env: set DRY_RUN)

			    -n|--network = The name of the network. (env: NETWORK=value)

			    -o|--output-dir = Where to write the results. (env: OUTPUT_DIR=value)

			    -v|--verbose = Set -x within the step. (env: set VERBOSE)

			Env vars:

			    STEPS = a regex matching the steps to run.  Steps have labels such
			        as 0.A.3 or 1.B.5.c.  If the regex matches the prefix, the
			        step will be executed.  Default:  Run all non-optional steps.

			    HSM_MODULE = path to the HSM module to use.  Examples:
			        SoftHSM on Ubuntu-20:       /usr/lib/x86_64-linux-gnu/softhsm/libsofthsm2.so
			        Nitrokey HSM on Ubuntu-20:  /usr/lib/x86_64-linux-gnu/opensc-pkcs11.so
			        Nitrokey HSM on OsX:        Not needed

			    Note: HSM refers to the master HSM, by default, but this isn't essential.
			    HSM_SLOT     = HSM slot number - otherwise the first slot with HSM in the title will be used.
			    HSM_PIN_FILE = File containing the pin to access the HSM; CI should use TEST PINS ONLY.
			    HSM_KEY_ID   = Key ID of the master key

			    RELEASE_COMMIT = commit of build artefacts to use.  Default:  Current commit.

			    PR = PR of the release commit build.  Default:  The current PR.

			    PROD_SRC = the path to the /testnet directory in the git repo.  Default: The /testnet in the current git repo.
			        Warning: This has not been tested inside git workspaces.
		EOF
            exit 0
            ;;
        -d | --dry*)
            shift 1
            DRY_RUN=very_dry
            ;;
        -n | --network)
            export NETWORK="$2"
            shift 2
            ;;
        -o | --output-dir)
            results_dir="$2"
            shift 2
            ;;
        -v | --verbose)
            shift 1
            VERBOSE=garrulous
            ;;
        *)
            if (($# == 1)); then
                STEPS="$1"
                break
            else
                printf "ERROR: %s\n" "Unsupported argument: $1" >&2
                exit 1
            fi
            ;;
    esac
done

test -n "${results_dir:-}" || {
    printf "ERROR: %s\n" \
        "Output dir not specified." \
        "Please use the flag: -o <DIR>" >&2
    exit 1
}
test -d "$(dirname "${results_dir}")" || {
    printf "ERROR: %s\n" \
        "Output dir is not a directory:" \
        "'$results_dir'" >&2
    exit 1
}
test -n "${NETWORK:-}" || {
    printf "ERROR: %s\n" \
        "Network not specified." \
        "Please use the flag: -n <NETWORK>" >&2
    exit 1
}
test -d "$(git rev-parse --show-toplevel)/testnet/env/${NETWORK}" || {
    printf "ERROR: %s\n" \
        "Network not defined" \
        "These networks are defined:" \
        "$(find "$(git rev-parse --show-toplevel)/testnet/env/" -maxdepth 1 -type d | xargs -I{} basename "{}" | tr "\n" " ")" >&2
    exit 1
}

PROD_SRC="${PROD_SRC:-$(git rev-parse --show-toplevel)/testnet}" # Warning: This fallback will work inside a git repo only.

if [[ $NETWORK == "mercury" ]]; then
    echo >&2 "This script is not intended to run against the 'mercury' network. Aborting."
    exit 1
fi

if [[ ! -d "$PROD_SRC/env/$NETWORK" ]]; then
    echo >&2 "'$NETWORK' doesn't exist (checked at '$PROD_SRC/env/$NETWORK'), aborting."
    exit 1
fi

if [[ ! -d $results_dir ]]; then
    echo >&2 "'$results_dir' does not exist, will be created..."
fi

if [[ $results_dir != /* ]]; then
    echo >&2 "'$results_dir' is not an absolute path, converting to absolute..."
    results_dir="$PWD/$results_dir"
fi

echo "Starting bootstrap test on network with identifier $NETWORK."

# Helper function to convert times
dateFromEpoch() {
    date --date="@$1"
}

# Store the test start time in epoch, so we could query Prometheus later.
starttime="$(date '+%s')"
echo "Testcase start time: $(dateFromEpoch "$starttime")"

cd "$PROD_SRC"

ARCH="$(if uname | grep -q Darwin; then echo -n x86_64-darwin; else echo -n x86_64-linux; fi)"
export ARCH

# Requirements:
# - Make it clear which commands have a side-effect in the shell
#   - Done by running side-effect free commands in a subshell () vs {}.
# - Run just some commands
STEPS_PATTERN="^(${STEPS:-.*})([.].*|$)"
ENV_FILE="${results_dir}/env_vars"
BIN_DIR="${results_dir}/bin"

echo ENV_FILE = "$ENV_FILE"
NUM_STEPS_MATCHED=0
step() {
    # Runs a named step if the name matches the env var STEPS.
    # Optional steps are skipped unless STEPS matches the step name exactly.
    if [[ "$1" == "--optional" ]]; then
        local optional="1"
        shift 1
    else
        local optional=""
    fi
    STEP="$1"
    if [[ "$STEP" =~ $STEPS_PATTERN ]]; then
        ((NUM_STEPS_MATCHED++))
        test -n "${DRY_RUN:-}" || printf "\n\n"
        echo "#$(echo "$1" | tr -cd '.' | tr . '#')${optional:+ (Optional)} $*"
        test -e "$ENV_FILE" || touch "$ENV_FILE"
        # shellcheck disable=SC1090
        source "$ENV_FILE"
        # Nothing more to do if:
        #    this is a dry run
        # OR the step is optional and doesn't match the filter exactly.
        if test -n "${DRY_RUN:-}" || { test -n "${optional:-}" && [[ "$STEP" != "${STEPS:-}" ]]; }; then
            : Skipping step "$STEP"
        else
            echo "Start: $(date -u --rfc-3339=seconds)"
            echo "$STEP	$(date -u --rfc-3339=seconds)" >>"$results_dir/step_log"

            false
        fi
    else
        true
    fi
}

function yaml2json() {
    if [[ -n "${1:-}" ]]; then
        cat "$1" | python3 -c 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)'
    else
        python3 -c 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)'
    fi
}

precompute_ipv6() {
    : Needs NETWORK SUBNET ande node_index

    #gateway="$(ip -6 neigh | grep -vE '^fe80' | grep router | awk '{printf "%s", $1 ; exit 0}')"
    cat <<-"EOF" >commands
	virsh dumpxml guest | xmllint --xpath 'string(/domain/devices/interface[target[@dev="vnet1"]]/mac/@address)' -
	EOF

    ansible -m debug -a "var=hostvars[inventory_hostname].inventory_hostname" -i "${GIT_ROOT}/testnet/env/$NETWORK/metal_hosts" "$SUBNET" \
        | grep 'inventory_hostname"' \
        | awk -F'"' '{print $4}' \
        | while read -r hostname; do
            local dc="$(echo "$hostname" | awk -F. '{print $2}')"
            local prefix="$(yaml2json "$GIT_ROOT/testnet/env/shared-config.yml" | dc="$dc" jq -r '.data_centers["\(env.dc)"].vars.ipv6_prefix')"
            local mac="$(ssh <commands "$hostname" sudo bash)"
            local ipv6="$("$GIT_ROOT"/testnet/tools/ipv6-calc.py --prefix "${prefix}" --mac-adress "${mac}")"
            test -n "${ipv6}" || {
                echo "failed to get guest address for hostname='$hostname' dc='$dc' prefix='$prefix' mac='$mac' ipv6='$ipv6'"
                exit 1
            }
            printf "%s node_index=$((++node_index)) dfinity_node=yes stage=all ansible_host=%s macv6=%s ipv6=%s\n" "${NETWORK}.${hostname}.guest" "${NETWORK}.$hostname.guest" "$mac" "$ipv6"
            set +x
        done | tee "${results_dir}/${SUBNET}"
}

# Function to preserve vars to be used over multiple steps, so that they are still there if the shell is killed.
setvar() {
    printf 'export %s=%q\n' "$1" "$2" >>"$ENV_FILE"
    # Shellcheck cannot find this file.  that is OK, as it is created afresh for each run.
    # shellcheck disable=SC1090
    source "$ENV_FILE"
}

set_verbosity() {
    test -z "${VERBOSE:-}" || set -x
}

load_pin() {
    HSM_PIN="$(sed -n 1p "$HSM_PIN_FILE" | tr -cd '0-9')"
    export HSM_PIN
    export DFX_HSM_PIN="$HSM_PIN"
}

# Name of a deployment branch from the current commit
branch_name() {
    echo "deploy_$(git rev-parse --short HEAD)"
}

record_network_topology_from_url() {
    (
        set -eu
        nns_url="$1"
        label="${2:-}"
        network_file="$results_dir/$STEP${label:+-$1}-network-topology.json"
        ic-admin --nns-url "$nns_url" get-topology >"$network_file"
        echo "Network topology written to: $network_file" >&2
        echo "$network_file"
    )
}

is_live_ipv6() {
    ipv6="$1"
    curl --fail --silent http://[${ipv6}]:8080/_/dashboard >/dev/null 2>/dev/null
}

# Status is no longer provided so we need to deduce it
parse_status() {
    awk 'BEGIN{state="Accepted"}(($1=="executed_timestamp_seconds")&&($3 != 0)){state="AcceptedAndExecuted"}(($1=="tally_at_decision_time")&&($3=="null")){status="Open"}END{print(status)}'
}
wait_for_proposal_execution() {
    (
        local NETWORK="$1"
        local PROPOSAL="$2"
        cd "$GIT_ROOT/rs/nns"

        expected="true"
        status_file="${results_dir}/${NETWORK}-proposal-${PROPOSAL}.idl"
        printf "\nWaiting for the proposal to be executed\nStatus in: %s\n\n" "$status_file"
        for ((retries = 100; ; retries--)); do
            # Wait until time has been spent on execution.
            state="$(dfx --identity "${IC_SUPPORT}" canister --no-wallet --network="$NETWORK" call governance get_proposal_info "${PROPOSAL}" | tee "${status_file}" | idl2json | jq '(.[0].executed_timestamp_seconds|tonumber) > 0')"
            printf '\r Expected state: %12s  Actual state: %12s  with %3d tries left' "$expected" "$state" "$retries"
            if [[ "$state" == "$expected" ]]; then
                printf '\n\nOK\n\n'
                break
            elif ((retries > 0)); then
                sleep 10
            else
                echo
                printf "ERROR: %s\n" \
                    "Proposal has not been executed." \
                    "Expected state: $expected" \
                    "Actual state:   $state"
                exit 1
            fi
        done
    )
}
wait_for_proposal_approval() {
    (
        local NETWORK="$1"
        local PROPOSAL="$2"
        cd "$GIT_ROOT/rs/nns"

        expected="true"
        status_file="${results_dir}/${NETWORK}-proposal-${PROPOSAL}.idl"
        printf "\nWaiting for the proposal to be approved\nStatus in: %s\n\n" "$status_file"
        for ((retries = 100; ; retries--)); do
            # Wait until time has been spent on execution.
            state="$(dfx --identity "${IC_SUPPORT}" canister --no-wallet --network="$NETWORK" call governance get_proposal_info "${PROPOSAL}" | tee "${status_file}" | idl2json | jq '.[0]|((.decided_timestamp_seconds|tonumber)>0) and ((.latest_tally[0].yes|tonumber)>(.latest_tally[0].total|tonumber)/2)')"
            printf '\r Expected state: %12s  Actual state: %12s  with %3d tries left' "$expected" "$state" "$retries"
            if [[ "$state" == "$expected" ]]; then
                printf '\n\nOK\n\n'
                break
            elif ((retries > 0)); then
                sleep 10
            else
                echo
                printf "ERROR: %s\n" \
                    "Proposal has not been accepted." \
                    "Expected state: $expected" \
                    "Actual state:   $state"
                exit 1
            fi
        done
    )
}

get_node_operator_allowances() {
    local nns_url="$1"
    node_operator_allowances_dir="${results_dir}/${STEP}-node-operator-allowances"
    rm -fr "$node_operator_allowances_dir"
    mkdir "$node_operator_allowances_dir"

    # get the node allowance for each node opearor
    ic-admin --nns-url $nns_url get-node-operator-list | xargs -P20 -I{} bash -c "ic-admin --nns-url '$nns_url' get-node-operator --node-operator-principal-id '{}' > '${node_operator_allowances_dir}/{}'"

    # Return the sum of the node allowances.
    {
        echo 0
        find "$node_operator_allowances_dir" -type f | xargs -I{} sed -nr 's/.*node_allowance: *([0-9]+).*/ \1 +/g;ta;b;:a;p' "{}"
        echo p
    } | tr -d "\n" | dc | tee "$node_operator_allowances_dir/total"
}

# Get data from ansible, without ssh.
ansible_data() {
    # Arguments:
    local hosts_file="$1"                      # Typically env/$NETWORK/hosts
    local group="$2"                           # An ansible hostgroup such as 'nns' or 'subnets' or a combination as defined here: https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html
    local key="hostvars[inventory_hostname]$3" # A path into Ansible's hostvars (for which I cannot find a spec).

    # Print the requested variable, one line per entry, without quotes.
    # Note: We use debug to avoid ssh to nodes.
    ansible -m debug -a "var=$key" -i "$hosts_file" "$group" | sed -E 's/^[^{]* =>//g' | key="$key" jq '.[env.key]' | tr -d '"'
}

echo

# Note: The stage -1 steps are now not in Alpha 2.0 Runbook: https://docs.google.com/document/d/1Er2YuD0KNKkQ9EGdPVymqEEWpr9JEAOqHP5MscjIcJc/edit#
step -1 Destroy environment || true

step -1.A Destroy env || time (
    set_verbosity
    if test -d "${results_dir}"; then
        backup="$(mktemp -d "${results_dir}.XXXXXX")"
        mv "$results_dir" "$backup"
        echo "If there was a results dir it is safest to restart, to make sure that no variables have polluted the environment"
        exit 1
    else
        echo "Created empty results dir: $results_dir"
        mkdir "$results_dir"
    fi
)
step -1.B Destroy branch || time (
    set_verbosity
    LAST_DEPLOYMENT_BRANCH="$(branch_name)"
    if git branch --list "$LAST_DEPLOYMENT_BRANCH" | grep -q .; then
        git branch -d "$LAST_DEPLOYMENT_BRANCH"
        git push
    else
        echo No branch to remove
    fi
)
step -1.C.0 Depopulate the hosts sections || time (
    GIT_ROOT="$(git rev-parse --show-toplevel)"
    sed -ir '/\[subnet_1\]/{p;s/.*/#nodes to be added to "old" NNS/g;:a;n;/^[\[]/b;s/.*//g;ba}' "${GIT_ROOT}/testnet/env/${NETWORK}/parent_hosts"
    sed -ir '/\[subnet_2\]/{p;s/.*/#nodes to be added to "new" NNS/g;:a;n;/^[\[]/b;s/.*//g;ba}' "${GIT_ROOT}/testnet/env/${NETWORK}/parent_hosts"
    sed -ir '/\[nns\]/{p;s/.*/#nodes to be added to "new" NNS/g;:a;n;/^[\[]/b;s/.*//g;ba}' "${GIT_ROOT}/testnet/env/${NETWORK}/hosts"
    sed -ir '/\[subnet_[0-9]+\]/{p;s/.*/#nodes to be added to the Nth app subnet/g;:a;n;/^[\[]/b;s/.*//g;ba}' "${GIT_ROOT}/testnet/env/${NETWORK}/hosts"
    git commit -m "Comment out hosts" "${GIT_ROOT}/testnet/env/${NETWORK}/hosts" "${GIT_ROOT}/testnet/env/${NETWORK}/parent_hosts"
)
step -1.C.1 Destroy testnet || time (
    set -eu
    set_verbosity
    cd "$(git rev-parse --show-toplevel)/prod"
    echo "Root node:"
    ansible -i "env/$NETWORK/parent_hosts" nns --list-hosts
    read -p "Destroy $NETWORK root node? [y/N] " answer
    [[ "$answer" =~ ^[Yy] ]] || exit 1
    : For a clean installation, we can skip destroy steps.
    ansible-playbook -vv ic_env_destroy.yml \
        -i "env/$NETWORK/parent_hosts" \
        --limit nns \
        -e yes_i_confirm=yes
)
step -1.C.2 Destroy guests || time (
    set -eu
    set_verbosity
    cd "$(git rev-parse --show-toplevel)/prod"
    ansible -i "env/$NETWORK/metal_hosts" all --list-hosts
    read -p "Destroy all $NETWORK virtual machines? [y/N] " answer
    [[ "$answer" =~ ^[Yy] ]] || exit 1
    /usr/bin/ansible-playbook ansible/roles/ic_guest_prod/playbook.yml \
        -i "env/$NETWORK/metal_hosts" \
        --limit all \
        -e ic_state=destroy \
        --user terraform
)

step 0 Preparation || true

export PATH="$BIN_DIR:$PATH"
mkdir -p "$BIN_DIR"

# Always check disk and RAM on every run.
(
    min_ram_Gi=4
    min_disk_Gi=5
    case "$ARCH" in
        *-darwin)
            ram_available_Gi="$(df -h . | awk '(NR==2){print $4}' | xargs numfmt --from=auto --to-unit=Gi)"
            ;;
        *-linux)
            ram_available_Gi="$(free -g | awk '($1=="Mem:"){print $7}')"
            ;;
        *)
            printf "ERROR: %s\n" "Don't know how to get available RAM for arch $ARCH"
            exit 1
            ;;
    esac
    disk_available_Gi="$(df -h . | awk '(NR==2){print $4}' | xargs numfmt --from=auto --to-unit=Gi)"
    echo Checking disk space
    ((disk_available_Gi >= min_disk_Gi)) || {
        printf "ERROR: %s\n" "Insufficient free disk space to proceed safely." "Please delete files or use a larger drive." "You can proceed when you have ${min_disk_Gi}Gi bytes free."
        exit 1
    }
    echo Checking RAM
    ((ram_available_Gi >= min_ram_Gi)) || {
        printf "ERROR: %s\n" "Insufficient free RAM to proceed safely." "Please stop memory-hungry processes." "You can proceed when you have ${min_ram_Gi}Gi bytes free."
        exit 1
    }
)

step 0.A.0 "Prepare the deployment branch variables" || time (
    set_verbosity
    mkdir -p "${results_dir}"
    setvar RELEASE_COMMIT "${RELEASE_COMMIT:-$(git rev-parse HEAD)}"
    setvar DEPLOYMENT_BRANCH "$(branch_name)"
    setvar GIT_ROOT "$(git rev-parse --show-toplevel)"
    setvar PROD_SRC "$PROD_SRC"
    setvar NETWORK "$NETWORK"
    setvar results_dir "$results_dir"
    # TODO: Make sure to base the release on the release commit.
)

step 0.A.0.1 "Check that git is clean" || time (
    set_verbosity
    if git status --untracked-files=no --porcelain | grep .; then
        echo "Git has unstaged changes.  Please commit them before proceeding."
        exit 1
    fi
)

step 0.A.0.2 "Check that downloads will be available" || time (
    set_verbosity
    # Warning: On OsX, grep -q "$RELEASE_COMMIT" fails when it shouldn't.
    git fetch
    git log --pretty=oneline origin/master | grep "$RELEASE_COMMIT" | grep -q . || {
        printf "WARNING %s\n" \
            "The release commit '$RELEASE_COMMIT' is not on master" \
            "This implies that download.dfinity.systems probably doesn't have the required artefacts."
        "This run is most likely to fail.  Proceed only if you know that this will be OK."
        exit 1
    }
    # In future all data should come from download.dinity.systems, not blobules, except when testing maybe sometimes.
)

step 0.A.0.3 "Check the super leader" || time (
    set_verbosity
    : Verify that the super-leader key file is present and correct
    SUPER_LEADER_KEY_FILE="${HOME}/.config/dfx/identity/${NETWORK}-super-leader/identity.pem"
    test -n "${SUPER_LEADER_KEY_FILE:-}" || {
        printf "ERROR: %s\n" \
            "SUPER_LEADER_KEY_FILE is not defined." \
            "The file can usually be downloaded from a 1Pass vault."
        exit 1
    }
    : Verify that the key is present
    test -f "${SUPER_LEADER_KEY_FILE}" || {
        printf "ERROR: %s\n" \
            "SUPER_LEADER_KEY_FILE '$SUPER_LEADER_KEY_FILE' is not a file."
        exit 1
    }
    setvar SUPER_LEADER_KEY_FILE "$SUPER_LEADER_KEY_FILE"
)

step 0.A.0.4 "Check the ops key" || time (
    # TODO: In future we should have a separate ops key for each network, not use the IC_SUPPORT key that has additional privileges.
    # At the moment this is hard wired in ansible (probably).  needs to be injected when we bootstrap.
    set_verbosity
    : Verify that the ops key file is present and correct
    IC_SUPPORT_KEY_FILE="${HOME}/.config/dfx/identity/${NETWORK}-support/identity.pem"
    test -n "${IC_SUPPORT_KEY_FILE:-}" || {
        printf "ERROR: %s\n" \
            "IC_SUPPORT_KEY_FILE is not defined." \
            "The file can usually be downloaded from a 1Pass vault."
        exit 1
    }
    : Verify that the key is present
    test -f "${IC_SUPPORT_KEY_FILE}" || {
        printf "ERROR: %s\n" \
            "IC_SUPPORT_KEY_FILE '$SUPER_LEADER_KEY_FILE' is not a file."
        exit 1
    }
    setvar IC_SUPPORT_KEY_FILE "$IC_SUPPORT_KEY_FILE"
)

step 0.A.0.5 "Check that the current branch forked from master at the release commit" || time (
    fork="$(git merge-base HEAD origin/master)"
    [[ "$fork" == "$RELEASE_COMMIT" ]] || {
        echo "This branch forked from master at: $fork"
        echo "But therelease commit is:          $RELEASE_COMMIT"
        exit 1
    }
)

step 0.A.0.6 "Check that the guest ssh keys are present" || time (
    dir="$GIT_ROOT/testnet/env/$NETWORK/ssh_keys"
    test -d "$dir" || {
        echo "ERROR: The guest ssh keys should be in: $dir"
        exit 1
    }
    dir="$GIT_ROOT/testnet/env/$NETWORK/ssh_keys_lockout"
    test -d "$dir" || {
        echo "ERROR: The independent guest ssh keys should be in: $dir"
        exit 1
    }
)

step 0.A.1 "Create deployment branch" || time (
    set_verbosity
    # We assume that we are already on the release commit; we should
    # be in the nix-shell for that commit, otherwise reproucability is not guaranteed.
    #
    # Comment from the doc:
    # This is to avoid discrepancies between the binaries of the release commit and the ones from the deployment branch.
    pwd
    git switch -c "$DEPLOYMENT_BRANCH"
    git commit --allow-empty -m "Bootstrapping Branch"
    git push --set-upstream origin "$DEPLOYMENT_BRANCH"
    hub pull-request -d -m "Bootstrapping from $DEPLOYMENT_BRANCH"
    setvar PR "${PR:-$(hub pr show -f %I)}"
)

step 0.A.2 "Populate dfx.json" || time (
    set_verbosity
    : "Check if the file 'dfinity/rs/nns/dfx.json' contains a '${NETWORK}' network using any node listed in the 'dfinity/testnet/env/${NETWORK}/hosts' file under [nns]. Otherwise add an entry in 'networks' called '${NETWORK}' network, e.g."

    dfx_file="$GIT_ROOT/rs/nns/dfx.json"
    # TODO: Export NNS_HOST and BOOTSTRAP_NNS_HOST and replace parent_nns_host and child_nns_host.

    # Add the network
    NNS_HOST="$(ansible_data "env/$NETWORK/hosts" nns .ipv6 | head -n1)"
    NNS_URL="http://[${NNS_HOST}]:8080"
    export NNS_URL
    contents="$(jq --indent 2 '.networks["\(env.NETWORK)"]={"type":"persistent", "providers": ["\(env.NNS_URL)"]}' "$dfx_file")"
    echo "$contents" >"$dfx_file"

    # Add the bootstrap network as well.
    # TODO: Nothing is listening on port 8080.  Motivation:  Getting the status of a proposal.  Possible alternative:  Can ic-admin get the status of a proposal without port 8080?
    BOOTSTRAP_NNS_HOST="$(ansible_data "env/$NETWORK/parent_hosts" nns .ipv6 | head -n1)"
    BOOTSTRAP_NNS_URL="http://[$BOOTSTRAP_NNS_HOST]:8080"
    export BOOTSTRAP_NNS_URL
    contents="$(jq --indent 2 '.networks["bootstrap_\(env.NETWORK)"]={"type":"persistent", "providers": ["\(env.BOOTSTRAP_NNS_URL)"]}' "$dfx_file")"
    echo "$contents" >"$dfx_file"

    # Save
    git commit --allow-empty -m "Update dfx file at: $dfx_file" "$dfx_file"
)

step 0.A.4 "Populate canister IDs" || time {
    set_verbosity
    original="$GIT_ROOT/rs/nns/canister_ids.json"
    tempfile="$(mktemp)"
    {
        # Include the original:
        cat "$original"
        # Clone the nnstestnet canister IDs, substituting NETWORK for "nnstestnet"
        jq <"$original" '. as $in| keys[] | {(.): {(env.NETWORK):$in[(.)].nnstestnet}}'
        jq <"$original" '. as $in| keys[] | {(.): {"bootstrap_\(env.NETWORK)":$in[(.)].nnstestnet}}'
    } | jq -s 'reduce .[] as $item ({}; . * $item)' >"$tempfile"
    mv "$tempfile" "$original"
}

step --optional 0.A.5 "Rebuild the canister did files" || time (
    set_verbosity
    pushd "$GIT_ROOT/rs"
    jq <nns/canister_ids.json -r 'keys[]' | while read -r canister; do
        if test -d "nns/$canister"; then
            echo "Building canister did file: $canister"
            nix-shell --command "cd nns/$canister && cargo run --bin ${canister}-canister --release > canister/${canister}.did" || echo "$canister failed"
        else
            echo "Skipping canister - no code found: $canister"
        fi
    done
)

step 0.A.6 "Populate the canister .did files" || time (
    set_verbosity
    echo the following was extracted from these instructions: https://gitlab.com/dfinity-lab/core/ic/blob/master/rs/nns/README.adoc#interacting-with-an-existing-nns
    pushd "$GIT_ROOT/rs/nns"
    jq <canister_ids.json -r 'keys[]' | while read -r canister; do
        did_file="$GIT_ROOT/rs/nns/${canister}/canister/${canister}.did"
        if test -e "$did_file"; then
            for network in "$NETWORK" "bootstrap_$NETWORK"; do
                echo "Addding canister '$canister' to dfx directory for '$network' network."
                target_dir="$GIT_ROOT/rs/nns/.dfx/$network/canisters/${canister}/"
                mkdir -p "$target_dir"
                cp "$did_file" "$target_dir"
            done
        else
            echo "Skipping canister '$canister' because of missing .did file: '$did_file'"
        fi
    done
    echo "Network canister files:"
    find "$GIT_ROOT"/rs/nns/.dfx/{"bootstrap_${NETWORK}","${NETWORK}"}/canisters/ -type f
)

step 0.A.7 "Sanity check the hosts files" || time {
    : Sanity check: parent_hosts.subnet_2 should be the same as hosts.nns
    hosts_in_one_only="$({
        ansible_data "env/$NETWORK/parent_hosts" subnet_2 .ansible_host
        ansible_data "env/$NETWORK/hosts" nns .ansible_host
    } | sort | uniq -u)"
    test -z "$hosts_in_one_only" || {
        printf "ERROR: %s\n" \
            "These should be the same:" \
            "subnet_2 in 'env/$NETWORK/parent_hosts'" \
            "nns in 'env/$NETWORK/hosts'" \
            "Actual delta:" \
            "$hosts_in_one_only"
        exit 1
    }
    : Sanity check: node_index should be unique
    duplicates="$(ansible_data "env/$NETWORK/hosts" nns:subnets .node_index | uniq -D | uniq | tr "\n" " ")"
    test -z "${duplicates:-}" || {
        printf "ERROR: %s\n" \
            "In the hosts file, the node_index should be unique." \
            "Duplicates: $duplicates"
        exit 1
    }
}

step 0.B Prepare the shell || true

step 0.B.1 "Set environment variables" || time (
    set_verbosity
    set_verbosity
    test -n "$PR"
    test -n "$NETWORK"

    setvar parent_nns_host "$(ansible_data "env/$NETWORK/parent_hosts" nns .ipv6 | head -n1)"
    setvar parent_nns_url "http://[$parent_nns_host]:8080"
)

step 0.B.2.A "Get artefacts" || time (
    set_verbosity
    : "Get artefacts.  We do not need the boot image here."
    : "TODO : disable auth"
    sed 's/true/false/g' "$GIT_ROOT/.rclone.conf" >"$results_dir/.rclone-noauth.conf"
    download_dir="$results_dir/artefacts"
    rm -fr "${download_dir:-THIS-IS-NOT-THE-DIR-YOU-ARE-LOOKING-FOR}"
    mkdir "$download_dir"
    rclone --config "$results_dir/.rclone-noauth.conf" --progress copyto "public-s3:dfinity-download/blessed/ic/$RELEASE_COMMIT/" "$download_dir"
)

step 0.B.2.B "Use non-nix ansible" || time (
    mkdir -p "$results_dir/bin"
    cd "$results_dir/bin"
    rm -f ansible
    ln -s /usr/bin/ansible ansible
)

step 0.B.2.C "Install ic-admin" || time (
    set -eux
    : Install ic-admin
    cd "$results_dir"
    gunzip <"$results_dir/artefacts/x86_64-linux/ic-admin.tar.gz" | tar -x
    mkdir -p "$results_dir/bin"
    mv -f ic-admin "$results_dir/bin"
)

step 0.B.2.D "Install ic-nns-init" || time (
    gunzip <"$results_dir/artefacts/nix-release/ic-nns-init.gz" >"$results_dir/bin/ic-nns-init"
    chmod +x "$results_dir/bin/ic-nns-init"
)

step 0.B.2.E "Install ic-prep" || time (
    gunzip <"$results_dir/artefacts/nix-release/ic-prep.gz" >"$results_dir/bin/ic-prep"
    chmod +x "$results_dir/bin/ic-prep"
)

step 0.B.3 "MacOS only: Avoid Gatekeeper" || time (
    set_verbosity
    [[ "$ARCH" == "x86_64-darwin" ]] || exit 0
    echo
    echo
    echo "MacOS only: On MacOS, downloaded binaries may be blocked by Gatekeeper. If so, run open $BIN_DIR, then right-click on the ic-admin executable and select 'Open', to avoid later assumptions that it is malware."
    echo
    echo
    echo Press ENTER to proceed
    read -r
    echo Opening...
    open "$BIN_DIR"
    echo Press ENTER when you have run ic-admin
    read -r
    echo Thank you.
)

step 0.C "Make sure that HSMs are plugged in" || true

: "Always override the nix pkcs11-tool on Linux until the nix version is fixed. (TODO)"
case "$ARCH" in
    *-linux)
        test -e /usr/bin/pkcs11-tool || ln -s /usr/bin/pkcs11-tool "$BIN_DIR/pkcs11-tool"
        ;;
esac

step 0.C.1 "Make sure the local HSM is detected" || time (
    set_verbosity
    echo "Make sure that you have generated a root key per the instructions at: "
    echo "  https://www.notion.so/Instructions-for-the-key-creation-on-the-HSM-devices-85d628774d7b4e729e9163a4619f6bdb"
    pkcs11-tool ${HSM_MODULE:+--module ${HSM_MODULE}} --list-slots | grep -q "HSM" || {
        echo "HSM is not plugged in, or needs to be re-plugged if present."
        exit 1
    }

    HSM_SLOT="${HSM_SLOT:-$(pkcs11-tool --list-slots | sed -nr '/Nitrokey/{s/.*(0x[0-9]+).*/\1/g;ta;b;:a;p;q}')}"

    echo Verify that the local key is labelled Master
    # Sadly --list-slots together with --slot doesn't list just the one slot so we get the info for that slot out by regex.
    pkcs11-tool --list-slots | sed -nE "/^Slot\s+[0-9]+\s[(]${HSM_SLOT}[)]/,/^\S/{p}" | sed '${/^\S/d}' | grep -qE 'token label\s+:\sMaster' || {
        printf "WARNING: %s\n" \
            "Slot HSM_SLOT=$HSM_SLOT is not the master slot." \
            "If you have a Master and an IC OPS key you should probably use the master key for consistency."
    }

    echo Verify thet the pin file is defined and exists
    test -e "${HSM_PIN_FILE:-}" || {
        printf "ERROR: %s\n" \
            "File HSM_PIN_FILE = '${HSM_PIN_FILE:-}' not found"
        exit 1
    }
    load_pin

    echo Verify that the local HSM slot and pin are correct
    if pkcs11-tool --test --slot "$HSM_SLOT" --pin "$HSM_PIN" >/dev/null; then
        echo OK
    else
        printf "ERROR: %s\n" "HSM ERROR" "HSM vars seem to be incorrect or key '${HSM_KEY_ID:-}' has not been generated."
        exit 1
    fi

    echo Verify that the local key is present and can be used
    if pkcs11-tool --sign --id "$HSM_KEY_ID" -i <(echo foo) -o /dev/null --slot "$HSM_SLOT" --pin "$HSM_PIN" >/dev/null; then
        echo OK
    else
        printf "ERROR: %s\n" "HSM ERROR" "Can access slot but cannot sign with the given key ID."
        exit 1
    fi

    setvar HSM_SLOT "$HSM_SLOT"
    setvar HSM_KEY_ID "$HSM_KEY_ID"
    setvar HSM_PIN_FILE "$HSM_PIN_FILE"
)

# Avoid having to call this many times by calling it once here:
load_pin

: "If the root node has no HSM, this does not prevent everything from functioning"

step 0.C.3 "Make sure that bare metal hosts have HSMs plugged in" || {
    cd "$GIT_ROOT/testnet"
    ansible -i "env/$NETWORK/metal_hosts" all -m shell -a "lsusb | grep -E 'Nitro|Clay'"
}

step 0.C.4 "Verify that sufficient public keys have been imported from google drive" || time (
    num_distinct_hosts="$({ # Each of these will neeed an HSM:
        ansible_data "./env/$NETWORK/parent_hosts" subnets .ansible_host
        ansible_data "./env/$NETWORK/hosts" nns:subnets .ansible_host
    } | sort | uniq | wc -l)"
    # Each of these HSMs needs to be plugged in.  One HSM may later be used for additional nodes but at this step it is one per node.
    key_list_file="env/$NETWORK/data_centers/meta.json"
    num_public_key_files="$(jq <"$key_list_file" length)"
    ((num_distinct_hosts <= num_public_key_files)) || {
        printf "ERROR: %s\n" \
            "Insufficient data centre keys listed in:" \
            "    $(realpath "$key_list_file")" \
            "Each node involved in boostrapping and the initial network needs an HSM." \
            "Num nodes: ${num_distinct_hosts}" \
            "Num keys:  ${num_public_key_files}" \
            "Keys may be imported from google drive with steps similar to these:"
        cat <<-"EOF"


			# Star the Genesis folder so that it appears in Google's "My Drive".

			# Import key files:
			find "$HOME/Google Drive/My Drive/Genesis/" -maxdepth 1 -type f -name "*dc[-_]*.der"  | xargs -I{} install -m 644 "{}" "env/${NETWORK}/data_centers/"

			# Write a new key listing:
			ls "env/${NETWORK}/data_centers/" | sed -nr 's/(.*)[.]der$/    "\1": { "node_allowance": 2 },/g;ta;b;:a;p' | sed '1{s/^ /{/g};${s/,$/}/g}' > "env/${NETWORK}/data_centers/meta.json"

			# IMPORTANT! Correct the node allowances.  This is a manual process.

			# Save the keys:
			git add "env/$NETWORK/data_centers/"
			git commit -m "Add data centre HSM keys" "env/$NETWORK/data_centers/"


		EOF
        exit 1
    }
)

step 0.C.5 "Verify that each listed public key is present" || time (
    jq <"env/${NETWORK}/data_centers/meta.json" -r 'keys[]' | xargs -P10 -I{} ls -l "env/${NETWORK}/data_centers/{}.der" >/dev/null
)

step 0.C.6 "Verify that the public keys are distinct" || time (
    echo "Looking for duplicate public keys:"
    if jq <"env/${NETWORK}/data_centers/meta.json" -r 'keys[]' | xargs -I{} bash -c 'printf "%s " "{}" ; openssl asn1parse -inform der -in "env/${NETWORK}/data_centers/{}.der" -item X509_PUBKEY | md5sum' | sort -k2,2 | uniq -D -f1 | awk '{print $2, $1}' | grep .; then
        printf "ERROR: %s\n" \
            "Public keys must be unique but the above are not"
        exit 1
    fi
)

# TODO: Verify that the node HSMs correspond to public keys in the list above.

step 0.D.1 "Set DFX credentials" || time (
    set_verbosity
    #  "Run dfx identity list. If the output does not contain alpha2-super-leader, then download the PEM file from the (misnamed) alpha2 registry mutator vault, then move that file to ~/.config/dfx/identity/alpha2-super-leader/identity.pem"
    # Now try dfx identity list again: it should be in the list. This identity will be used to vote on proposals.
    # TODO: How do we know that an existing super-leader key file is the right one?  Is it better to always install the key rather than relying on some unknown state?
    # ^^^ That is now taken care of in step 0.B.4.
    # TODO: get and save super-leader principal ID with:
    # cd ../rs/nns ; dfx --identity "$NETWORK-super-leader" identity get-principal
    # TODO: Get and save the SUPER_LEADER_NEURON_INDEX (maybe call it SUPER_LEADER_NEURON_INDEX?) by
    # awk -F';' -vpid="$SUPER_LEADER_PRINCIPAL_ID" '($2==pid){print $1; exit}' env/bootstrap/initial-neurons.csv
    SUPER_LEADER="${NETWORK}-super-leader"
    test_leadership_skills() {
        dfx identity list | grep -qw "$SUPER_LEADER" || {
            echo Not a super-leader
            return 1
        }
        diff "$SUPER_LEADER_KEY_FILE" "$HOME/.config/dfx/identity/$SUPER_LEADER/identity.pem" || {
            echo Super leader has a different key
            return 1
        }
    }
    improve_leadership_skills() {
        echo Making a SUPER LEADER
        mkdir -p "$HOME/.config/dfx/identity/$SUPER_LEADER"
        cp "$SUPER_LEADER_KEY_FILE" "$HOME/.config/dfx/identity/$SUPER_LEADER/identity.pem"
    }
    improve_leadership_skills && test_leadership_skills
    setvar SUPER_LEADER "$SUPER_LEADER"
)
step 0.D.2 "Verify that the super leader has a neuron" || time (
    set_verbosity
    set -euo pipefail

    PRINCIPAL_NAME="$NETWORK-super-leader"
    PRINCIPAL_ID="$(
        cd ../rs/nns
        dfx --identity "$PRINCIPAL_NAME" identity get-principal || {
            printf "ERROR: %s\n" "No principal: '$PRINCIPAL_NAME'" >&2
            exit 1
        }
    )"

    neurons_file="env/$NETWORK/initial-neurons.csv"
    NEURON_INDEX="$(
        awk -F';' -vpid="$PRINCIPAL_ID" '($2==pid){print $1; exit}' <"$neurons_file" | grep . || {
            printf "ERROR: %s\n" \
                "'${PRINCIPAL_NAME}' lacks a neuron" \
                "PRINCIPAL_ID = '$PRINCIPAL_ID'" \
                "neurons_file = '$neurons_file'" >&2
            exit 1
        }
    )"
    setvar SUPER_LEADER_PRINCIPAL_ID "$PRINCIPAL_ID"
    setvar SUPER_LEADER_NEURON_INDEX "$NEURON_INDEX"
)
step 0.D.3 "Set ops DFX credentials" || time (
    set_verbosity
    IC_SUPPORT="${NETWORK}-support"
    test_key() {
        dfx identity list | grep -qw "$IC_SUPPORT" || {
            echo No key by that name: "$IC_SUPPORT"
            return 1
        }
        diff "$IC_SUPPORT_KEY_FILE" "$HOME/.config/dfx/identity/$IC_SUPPORT/identity.pem" || {
            echo Super leader has a different key
            return 1
        }
    }
    install_key() {
        echo Adding a key
        mkdir -p "$HOME/.config/dfx/identity/$IC_SUPPORT"
        cp "$IC_SUPPORT_KEY_FILE" "$HOME/.config/dfx/identity/$IC_SUPPORT/identity.pem"
    }
    install_key && test_key
    setvar IC_SUPPORT "$IC_SUPPORT"
)

step 0.D.4 "Verify that the ic-support key has a neuron" || time (
    set_verbosity

    PRINCIPAL_NAME="$IC_SUPPORT"
    PRINCIPAL_ID="$(
        cd ../rs/nns
        dfx --identity "$PRINCIPAL_NAME" identity get-principal || {
            printf "ERROR: %s\n" "No principal: '$PRINCIPAL_NAME'" >&2
            exit 1
        }
    )"

    neurons_file="env/$NETWORK/initial-neurons.csv"
    NEURON_INDEX="$(
        awk -F';' -vpid="$PRINCIPAL_ID" '($2==pid){print $1; exit}' <"$neurons_file" | grep . || {
            printf "ERROR: %s\n" \
                "'${PRINCIPAL_NAME}' lacks a neuron" \
                "PRINCIPAL_ID = '$PRINCIPAL_ID'" \
                "neurons_file = '$neurons_file'" >&2
            exit 1
        }
    )"
    setvar IC_SUPPORT_PRINCIPAL_ID "$PRINCIPAL_ID"
    setvar IC_SUPPORT_NEURON_INDEX "$NEURON_INDEX"
)

step 0.E "Gather host facts and precompute guest facts" || time (
    set_verbosity
    set -euo pipefail
    "$GIT_ROOT/launch/gather_facts" | tee "${results_dir}/metal_facts" | "${GIT_ROOT}/launch/compute_guest_facts" >"${results_dir}/guest_facts"
)

step 1 "Install initial NNS node" || true

step 1.A "Destroy existing independent nodes to start from a clean slate" || time (
    set_verbosity
    : "This is optional if doing a clean deploy."
    : "This step is necessary in case a previous deployment failed in such a way that the nodes did not manage to register with the NNS."
    : "TODO: Also destroy the child application subnets.  Do this first."

    for subnet in subnet_1 subnet_2; do
        ansible-playbook -vv ic_subnet_destroy.yml \
            -i "env/$NETWORK/parent_hosts" \
            -e "ic_subnet=$subnet" \
            -e yes_i_confirm=yes
    done
)

step 1.A.2 "Wait for blobules" || time (
    : Some code still requires that...
    url="https://blobules.dfinity.systems/dfinity-ci-build.dfinity.pr-$PR/ic-nns-bundle/0.0.0/x86_64-linux/ic-nns-bundle-0.0.0.tar.gz"
    echo "Blobule needed: $url"
    for ((retries = 100; ; retries--)); do
        printf "\r Waiting for blobules from %s  Retries left: %3d" "$PR" "$retries"
        if curl --fail --silent "$url" >/dev/null; then
            printf "\nOK\n"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            printf "ERROR: %s\n" \
                "NETWORK TOPOLOGY ERROR" \
                "Wrong number of unassigned nodes" \
                "Expected: $expected_num_unassigned" \
                "Actual:   $num_unassigned" \
                "This is a new NNS; the registry should contain nothing but the NNS itself." \
                >&2
            exit 1
        fi
    done
)

step 1.B "Install the initial node of the NNS" || time (
    set_verbosity
    : "Run the following command to build ic-prep locally, generate keys for the initial NNS nodes, deploy the initial NNS nodes (including their crypto state), and install the NNS canisters."

    : "TODO: I believe that the HSM_MODULE doesn't need to be specified any more"
    : "TODO: This step fails on latest master. (Maybe)  Or the child NNS."
    HSM_MODULE=/nix/store/g03prfzs42lbs1r0m31pfizf8zlk9431-softhsm-2.6.1/lib/softhsm/libsofthsm2.so
    SOFTHSM2_CONF="/home/parallels/.config/softhsm2/softhsm2.conf"
    export SOFTHSM2_CONF # The env var is read by the HSM module.
    load_pin

    ansible-playbook -vv ic_nns_install.yml \
        -i "env/$NETWORK/parent_hosts" \
        -e ic_support_principal_id="$IC_SUPPORT_PRINCIPAL_ID" \
        -e anonymous_principal_id="2vxsx-fae" \
        -e governance_pb_file="${PROD_SRC}/env/$NETWORK/bootstrap-governance.pb" \
        -e with_hsm=yes \
        -e hsm_slot="${HSM_SLOT}" \
        -e hsm_key_id="${HSM_KEY_ID}" \
        -e hsm_pin="${HSM_PIN}" \
        -e yes_i_confirm=yes \
        -e ic_subnet=nns \
        -e ic_nodemanager_src="https://download.dfinity.systems/ic/$(jq -r .binary_revisions.all "env/$NETWORK/versions.json")/x86_64-linux/nodemanager.tar.gz" \
        -e ic_replica_src="https://download.dfinity.systems/ic/$(jq -r .binary_revisions.all "env/$NETWORK/versions.json")/x86_64-linux/ic-replica.tar.gz"
)

step 1.C "Check the installation was successful" || true

step 1.C.1 "Check the NNS has been installed by running the get-topology command" || time (
    set_verbosity
    network_file="$(record_network_topology_from_url "$parent_nns_url")"

    echo There should be one subnet...
    num_subnets="$(jq <"$network_file" '.topology.subnets | keys | length')"
    expected_num_subnets=1
    ((num_subnets == expected_num_subnets)) || {
        printf "ERROR: %s\n" "NETWORK TOPOLOGY ERROR" "Wrong number of subnets" "Expected: $expected_num_subnets" "Actual:   $num_subnets"
        exit 1
    }
    echo OK

    echo The subnet should have one member
    total_members="$(jq <"$network_file" '.topology.subnets | map(.records) | flatten | map(.value.membership) | flatten | length')"
    expected_num_members=1
    ((total_members == expected_num_members)) || {
        printf "ERROR: %s\n" "NETWORK TOPOLOGY ERROR" "Wrong number of nodes in subnet" "Expected: $expected_num_members" "Actual:   $total_members"
        exit 1
    }
    echo OK

    echo There should be no unassigned nodes
    num_unassigned="$(jq <"$network_file" '.topology.unassigned_nodes | length')"
    expected_num_unassigned=0
    ((num_unassigned == expected_num_unassigned)) || {
        printf "ERROR: %s\n" "NETWORK TOPOLOGY ERROR" "Wrong number of unassigned nodes" "Expected: $expected_num_unassigned" "Actual:   $num_unassigned" \
            "This is a new NNS; the registry should contain nothing but the NNS itself."
        exit 1
    }
    echo OK
)

step 1.C.2 "Get the principal ids" || time (
    network_file="$(record_network_topology_from_url "$parent_nns_url")"
    setvar parent_nns_principal "$(jq <"$network_file" -r '.topology.subnets | keys | .[]' | grep .)"
    setvar root_node_principal "$(jq <"$network_file" -r '.topology.subnets | values | map(.records[0].value.membership[0]) | .[]' | grep .)"
)

step 1.C.3 "Get the operators node allowance" || time (
    setvar total_node_operator_allowance "$(get_node_operator_allowances "$parent_nns_url")"
    echo "Total operators node allowance: $total_node_operator_allowance"
)

# TODO: Verify that the super-leader neuron is present.  Also the ic_sup, if we decide that ic_sup makes proposals and the super-leader votes.
# [nix-shell:~/dfn/dfinity/branches/bootstrap-master/rs/nns]$ dfx --identity bootstrap-super-leader canister --network="bootstrap_$NETWORK" call governance get_neuron_ids
# (vec { 49 })

step --optional 1.C.4 "Update the service discovery server so it's pointing at the correct NNS by running the 'Update Service Discovery' command" || (
    echo "Note: This is required for the testnet to appear in grafana"
    ansible-playbook -vv -i "env/${NETWORK}/parent_hosts" ic_p8s_service_discovery_install.yml
)

step 2 "Add independent parent and child NNS nodes" || true

PARENT_AND_CHILD_NNS_HOSTS="parent_nns_hosts${DEPLOY_INDEPENDENT_NODES:+_lockout}:child_nns_hosts${DEPLOY_INDEPENDENT_NODES:+_lockout}"

step 2.A Prepare || true

step 2.A.1 "Destroy existing guests" || (
    set_verbosity
    cd "$GIT_ROOT/testnet"
    /usr/bin/ansible-playbook ansible/roles/ic_guest_prod/playbook.yml -i "env/$NETWORK/metal_hosts" --limit "$PARENT_AND_CHILD_NNS_HOSTS" -e ic_state=destroy --user terraform
)

step 2.A.2 "Get the operators node allowance before deployment" || time (
    setvar total_node_operator_allowance "$(get_node_operator_allowances "$parent_nns_url")"
    echo "Total operators node allowance: $total_node_operator_allowance"
)

step 2.B "Create configuration media image" || true

step 2.B.1 "Get the ssh keys" || (
    rm -fr "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}"
    cp -R "$GIT_ROOT/testnet/env/${NETWORK}/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}" "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}"
)

step 2.B.2 "Get the root NNS public key" || (
    ic-admin --nns-url "${parent_nns_url}" get-subnet-public-key 0 "$results_dir/nns_public_key.pem"
)

step 2.B.3 "Verify that inputs are present" || (
    set -eux
    test -e "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}/admin"
    test -e "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}/readonly"
    test -e "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}/backup"
    test -e "$results_dir/nns_public_key.pem"
)

step 2.B.4 "Create the config media image" || (
    set -eux
    cd "$GIT_ROOT/ic-os/guestos/"
    : enter nix shell - or command - nix.
    rm -fr "${results_dir:-THIS-IS-NOT-THE-DIRECTORY-YOU-ARE-LOOKING-FOR}/config${DEPLOY_INDEPENDENT_NODES:+_lockout}"
    mkdir "$results_dir/config${DEPLOY_INDEPENDENT_NODES:+_lockout}"
    nix-shell --command "
        ./scripts/build-bootstrap-config-image.sh $results_dir/config${DEPLOY_INDEPENDENT_NODES:+_lockout}/media.img --accounts_ssh_authorized_keys $results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}/ --nns_url $parent_nns_url --nns_public_key $results_dir/nns_public_key.pem "
)

step 2.C "Verify that HSMs are present in the bare metal hosts" || time (
    test -z "${DEPLOY_INDEPENDENT_NODES:-}" || {
        echo skipping for independent nodes
        exit 0
    }
    : TODO: "This requires SSH access.  Hopefully the HSM issue will be resolved by the time we lose access! :-)"
    set_verbosity
    if ansible -i "env/$NETWORK/metal_hosts" "$PARENT_AND_CHILD_NNS_HOSTS" -a "bash -c 'lsusb | grep Nitro'"; then
        echo "All HSMs present"
    else
        echo Some HSMs were absent. Please try to reconnect them.
        echo
        echo THIS IS A WARNING ONLY - Nodes can be brought to life by inserting an HSM.
        echo Be careful not to insert an HSM into an independent node that is already provisioned.
        echo Provisioned nodes can be identified by light pattern: The blue light does not blink.
    fi
)

step 2.D "Create parent nns guest domains" || time (
    cd "${GIT_ROOT}/testnet"
    /usr/bin/ansible-playbook ansible/roles/ic_guest_prod/playbook.yml \
        -i "env/$NETWORK/metal_hosts" \
        --limit "$PARENT_AND_CHILD_NNS_HOSTS" \
        --user terraform \
        -e ic_state=create \
        -e ic_disk_sha="$RELEASE_COMMIT" \
        -e ic_media_path="$results_dir/config${DEPLOY_INDEPENDENT_NODES:+_lockout}/" \
        -e ic_deployment_name="$NETWORK"
)

step 2.E Start guest domains || time (
    test -z "${DEPLOY_INDEPENDENT_NODES:-}" || exit 0
    cd "${GIT_ROOT}/testnet"
    /usr/bin/ansible-playbook ansible/roles/ic_guest_prod/playbook.yml \
        -i "env/$NETWORK/metal_hosts" \
        --limit "$PARENT_AND_CHILD_NNS_HOSTS" \
        --user terraform \
        -e ic_state=start
)

step 2.F "Verify that parent nns nodes are registered in the NNS as unassigned" || time (

    set_verbosity
    # Query the NNS for the list of unassigned running the get-topology command, and check that all nodes listed in the parent_hosts file in subnet_1 are registered as unassigned nodes.

    network_file="$(record_network_topology_from_url "$parent_nns_url")"
    echo
    echo "Waiting can be boring.  Follow the action on the NNS:"
    echo "    ansible -i env/$NETWORK/parent_hosts -a 'journalctl -n1000 -u dfinity-node.service' nns"
    echo "And on the nodes:"
    echo "    ansible -i env/$NETWORK/parent_hosts -a 'journalctl -n20 -u dfinity-node.service' subnet_1"
    echo "And the topology, which is where we are waiting for the unassigned nodes to appear:"
    echo "    watch -d cat '$network_file'"
    echo

    for ((retries = 100; ; retries--)); do
        # Get ip addresses of all nodes known to the parent nns.
        "${GIT_ROOT}/launch/get_node_principal_ips" "$parent_nns_url" >"$results_dir/parent-node-principal-ips-2" \
            && mv "$results_dir/parent-node-principal-ips-2" "$results_dir/parent-node-principal-ips"
        # Compile guest facts, including the principal where known.
        "${GIT_ROOT}/launch/compute_guest_facts" <"${results_dir}/metal_facts" >"${results_dir}/guest_facts-2" \
            && mv "${results_dir}/guest_facts-2" "${results_dir}/guest_facts"
        # Check whether all the deployed nodes have principals.
        num_unassigned="$(cat "${results_dir}/guest_facts" \
            | grep -wE "groups=(parent_nns_hosts|child_nns_hosts)${DEPLOY_INDEPENDENT_NODES:+_lockout}" \
            | grep -vE 'principal=[a-zA-Z0-9]' \
            | wc -l || true)"
        # Report on progress, and loop if not all nodes have registered.
        printf "\r Waiting for: %3d  Retries left: %3d" "$num_unassigned" "$retries"
        if ((num_unassigned == 0)); then
            printf "\nOK\n"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            printf "ERROR: %s\n" \
                "REGISTRATION ERROR" \
                "All nodes should have registered with eth parent NNS and should have principals." \
                "These don't:" \
                >&2
            cat "${results_dir}/guest_facts" | grep -wE "groups=(parent_nns_hosts|child_nns_hosts)${DEPLOY_INDEPENDENT_NODES:+_lockout}" >&2
            exit 1
        fi
    done
)

step 2.G "Get the operators node allowance after deployment" || time (
    last_total="${total_node_operator_allowance:-0}"
    setvar total_node_operator_allowance "$(get_node_operator_allowances "$parent_nns_url")"
    echo "Total operators node allowance: $total_node_operator_allowance"
    echo "Delta:                          $((total_node_operator_allowance - last_total))"
    # TODO: Maybe check that that it has decremented by the expected value.
)

step 3 "Extend the Parent NNS" || true

step 3.A Add nodes to the NNS || time (
    set_verbosity
    grep <"${results_dir}/guest_facts" -E "groups=parent_nns_hosts" \
        | while read line; do (
            eval entry=$line
            echo $principal
        ); done \
        | xargs ic-admin --nns-url "$parent_nns_url" add-nodes-to-subnet 0
)

step 3.B "Check NNS was extended successfully" || time (
    set_verbosity
    echo Query the topology of the IC and check that the subnet_1 nodes have been added to the membership list of the NNS.

    topology_file="$(record_network_topology_from_url "$parent_nns_url")"
    num_nodes_in_the_subnet="$(jq <"$topology_file" '.topology.subnets|map(.records[0].value.membership)|.[]|length')"
    # Count how many should have joined the root node.  Do not expect those that failed to register to be included, although if they have come up in the meantime that is cool.
    # We do match both ethe _lockout and the non-lockout nodes.
    num_non_root_parent_nodes="$(grep <"${results_dir}/guest_facts" 'groups=parent_nns_hosts' | grep 'principal=[a-zA-Z0-9]' | wc -l || true)"
    ((${num_nodes_in_the_subnet:-0} == 1 + ${num_non_root_parent_nodes:-0}))
)

step 3.C "Wait until the newly added parent NNS nodes are up and running" || time (
    set_verbosity
    failure_file="${results_dir}/${STEP}-failures"
    echo "The addresses we are waiting for: $failure_file"
    function all_ok() {
        local failures="$(grep groups=parent_nns_hosts "$results_dir/guest_facts" \
            | grep 'principal=[a-zA-Z0-9]' \
            | sed -nr 's/.*ipv6=(\S+).*/\1/g;ta;b;:a;p' \
            | while read -r ipv6; do is_live_ipv6 "$ipv6" >/dev/null || echo "$ipv6"; done \
            | tee "${failure_file}")"
        test -z "${failures:-}"
    }
    for ((retries = 100; ; retries--)); do
        printf "\rTries left: %3d" "$retries"
        if all_ok 2>/dev/null; then
            printf "\n\nOK\n"
            grep groups=parent_nns_hosts "$results_dir/guest_facts" \
                | grep 'principal=[a-zA-Z0-9]' \
                | sed -nr 's/.*ipv6=(\S+).*/\1/g;ta;b;:a;p' \
                | xargs -I{} echo "http://[{}]:8080/_/dashboard"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            printf "ERROR: %s\n" \
                "Timeout waiting for parent_nns_hosts to come up"
            all_ok
            exit 1
        fi
    done
)

step --optional 3.D "Update the service discovery so that stats are available on grafana" || time (
    set_verbosity
    ansible-playbook -vv -i "env/${NETWORK}/parent_hosts" ic_p8s_service_discovery_install.yml
)

step 4 "Create child NNS" || true

step 4.A "Create the child NNS subnet" || time (
    set_verbosity
    set -o pipefail
    # Get child_nns nodes that have managed to register.
    NEW_NODE_IDS="$(grep groups=child_nns_hosts "${results_dir}/guest_facts" | grep -E 'principal=[0-9a-zA-Z]' | sed -nr 's/.*principal=(\S*).*/\1/g;ta;b;:a;p' | tr "\n" " ")"
    # NEW_NODE_IDS is meant to expand to multiple arguments
    # shellcheck disable=SC2086
    PROPOSAL_TO_CREATE_PARENT_SUBNET="$(
        #--test-neuron-proposer \
        ic-admin \
            -s "$SUPER_LEADER_KEY_FILE" \
            --nns-url "${parent_nns_url}" \
            propose-to-create-subnet \
            --subnet-handler-id "unused" \
            --ingress-bytes-per-block-soft-cap 2097152 \
            --max-ingress-bytes-per-message 3145728 \
            --max-ingress-messages-per-block 1000 \
            --unit-delay-millis 2000 \
            --initial-notary-delay-millis 2500 \
            --dkg-interval-length 99 \
            --gossip-max-artifact-streams-per-peer 20 \
            --gossip-max-chunk-wait-ms 15000 \
            --gossip-max-duplicity 1 \
            --gossip-max-chunk-size 4096 \
            --gossip-receive-check-cache-size 5000 \
            --gossip-pfn-evaluation-period-ms 3000 \
            --gossip-registry-poll-period-ms 3000 \
            --gossip-retransmission-request-ms 60000 \
            --subnet-type system \
            --proposer "${SUPER_LEADER_NEURON_INDEX}" \
            --start-as-nns \
            $NEW_NODE_IDS \
            | tee /dev/stderr | sed -nr '${s/^proposal\s+([0-9]+)$/\1/;ta;b;:a;p}' | grep .
    )"
    setvar PROPOSAL_TO_CREATE_PARENT_SUBNET "$PROPOSAL_TO_CREATE_PARENT_SUBNET"
)

step 4.B "Verify that votes have gone in" || time (
    wait_for_proposal_approval "bootstrap_$NETWORK" "$PROPOSAL_TO_CREATE_PARENT_SUBNET"
)

step 4.C "Execute the proposal" || time (
    cd "$GIT_ROOT/rs/nns"
    dfx --identity "${IC_SUPPORT}" canister --no-wallet --network "bootstrap_$NETWORK" call governance execute_eligible_proposals
)

step 4.D "Verify that the proposal has been scheduled for execution" || time (
    wait_for_proposal_execution "bootstrap_${NETWORK}" "$PROPOSAL_TO_CREATE_PARENT_SUBNET"
)

step 4.E "Get the child NNS principal id" || time (
    set_verbosity
    echo Check if the new subnet was created by running the following command and see if the IDs were added to the subnet

    network_file="$(record_network_topology_from_url "$parent_nns_url")"
    ((1 == "$(jq <"$network_file" -r '.topology.subnets|keys|.[]' | grep -v "$parent_nns_principal" | wc -l)")) || {
        printf "ERROR: Expected one subnet apart from the parent NNS\n" >&2
        exit 1
    }
    setvar child_nns_principal "$(jq <"$network_file" -r '.topology.subnets|keys|.[]' | grep -v "$parent_nns_principal")"
    test -n "${child_nns_principal:-}" || {
        printf "ERROR: %s\n" "Child NNS not set."
    }
    echo OK
)

step 4.F "Check that the child NNS nodes are listening on port 8080" || time {
    set_verbosity
    failure_file="${results_dir}/${STEP}-failures"
    echo "The addresses we are waiting for: $failure_file"
    function all_ok() {
        local failures="$(grep groups=child_nns_hosts "$results_dir/guest_facts" \
            | grep 'principal=[a-zA-Z0-9]' \
            | sed -nr 's/.*ipv6=(\S+).*/\1/g;ta;b;:a;p' \
            | while read -r ipv6; do is_live_ipv6 "$ipv6" >/dev/null || echo "$ipv6"; done \
            | tee "${failure_file}")"
        test -z "${failures:-}"
    }
    for ((retries = 100; ; retries--)); do
        printf "\rTries left: %3d" "$retries"
        if all_ok 2>/dev/null; then
            printf "\n\nOK\n"
            grep groups=child_nns_hosts "$results_dir/guest_facts" \
                | grep 'principal=[a-zA-Z0-9]' \
                | sed -nr 's/.*ipv6=(\S+).*/\1/g;ta;b;:a;p' \
                | xargs -I{} echo "http://[{}]:8080/_/dashboard"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            printf "ERROR: %s\n" \
                "Timeout waiting for child_nns_hosts to come up"
            all_ok
            exit 1
        fi
    done
}

step 4.G "Set the child NNS url and other hosts" || time (
    set_verbosity

    child_nns_ipv6="$(grep groups=child_nns_hosts "$results_dir/guest_facts" \
        | grep 'principal=[a-zA-Z0-9]' \
        | sed -nr 's/.*ipv6=(\S+).*/\1/g;ta;b;:a;p;q')"

    # Set child_nns_url in the env_var file:
    setvar child_nns_host "$child_nns_ipv6"
    setvar child_nns_url "http://[$child_nns_host]:8080"

    # Set the child nns url in dfx.json
    dfx_file="$GIT_ROOT/rs/nns/dfx.json"
    contents="$(jq --indent 2 '.networks["\(env.NETWORK)"]={"type":"persistent", "providers": ["\(env.child_nns_url)"]}' "$dfx_file")"
    echo "$contents" >"$dfx_file"

    # Insert the parent nns nodes
    # ... Blank out the section
    sed -ir '/\[subnet_1\]/{p;s/.*/#nodes to be added to "old" NNS/g;:a;n;/^[\[]/b;s/.*//g;ba}' "${GIT_ROOT}/testnet/env/${NETWORK}/parent_hosts"
    # ... Fill the section
    grep groups=parent_nns "$results_dir/guest_facts" | grep -E 'principal=[0-9a-zA-Z]' >"${results_dir}/parent_nns_hosts"
    sed -i -e '/\[subnet_1\]/r '"${results_dir}/parent_nns_hosts" "${GIT_ROOT}/testnet/env/${NETWORK}/parent_hosts"

    # Insert the child nns in the parent hosts file
    grep groups=child_nns "$results_dir/guest_facts" | grep -E 'principal=[0-9a-zA-Z]' >"${results_dir}/child_nns_hosts"
    # ... Blank out the section
    sed -ir '/\[subnet_2\]/{p;s/.*/#nodes to be added to "new" NNS/g;:a;n;/^[\[]/b;s/.*//g;ba}' "${GIT_ROOT}/testnet/env/${NETWORK}/parent_hosts"
    # ... Fill the section
    sed -i -e '/\[subnet_2\]/r '"${results_dir}/child_nns_hosts" "${GIT_ROOT}/testnet/env/${NETWORK}/parent_hosts"

    # Insert the child nns in the child hosts file
    # ... Blank out the section
    sed -ir '/\[nns\]/{p;s/.*/#nodes to be added to "new" NNS/g;:a;n;/^[\[]/b;s/.*//g;ba}' "${GIT_ROOT}/testnet/env/${NETWORK}/hosts"
    # ... Fill the section
    sed -i -e '/\[nns\]/r '"${results_dir}/child_nns_hosts" "${GIT_ROOT}/testnet/env/${NETWORK}/hosts"

    echo "For the real bootstrap run, ensure we dont have --disable-neuron-authz-for-tests"
    echo "in the role that is called."
    echo
    echo "Note: From now on, the commands use the hosts file instead of the parent_hosts file."
)

step 5 "Install NNS canisters on child NNS (HSM required)" || true

step 5.A Install canisters || time (
    # This may break.  If so contact the NNS team.  Luc is probably the best person.
    # 2vxsx-fae is the principal of the anonymous user: see
    # https://gitlab.com/dfinity-lab/core/ic/blob/cc615b849b8017c4aa0307737d61525fb56a9792/rs/types/base_types/src/principal_id.rs#L535

    set_verbosity
    load_pin
    ansible-playbook -vv \
        ic_nns_install.yml \
        -i "env/$NETWORK/hosts" \
        -e node_data_dir=/var/lib/ic/data \
        -e ic_support_principal_id="$IC_SUPPORT_PRINCIPAL_ID" \
        -e anonymous_principal_id="2vxsx-fae" \
        -e governance_pb_file="${PROD_SRC}/env/$NETWORK/initial-governance.pb" \
        -e with_hsm=yes \
        -e hsm_slot="$HSM_SLOT" \
        -e hsm_key_id="$HSM_KEY_ID" \
        -e hsm_pin="$HSM_PIN" \
        -e yes_i_confirm=yes \
        -e ic_subnet=nns \
        -e ic_no_destroy=yes \
        -e install_child_nns=yes
)

step 5.B Verify || time (
    set_verbosity
    num_running_subnet_2_canisters_preinstall=0
    random_child_nns_node_ip="$(if echo "$child_nns_host" | grep -q :; then echo "[$child_nns_host]"; else echo "$child_nns_host"; fi)"
    num_running_canisters="$(curl "http://${random_child_nns_node_ip}:9090" | awk '/replicated_state_registered_canisters{status="running"}/{print $2}')"
    ((num_running_canisters > num_running_subnet_2_canisters_preinstall)) || {
        printf "ERROR: %s\n" \
            "Expected to have more running canisters now than before" \
            "Num canisters before installing canisters:  ${num_running_subnet_2_canisters_preinstall}" \
            "Num canisters now:                          ${num_running_canisters}"
        exit 1
    }
    echo "OK: Have ${num_running_canisters} running canisters.  ($num_running_subnet_2_canisters_preinstall before)"
)

# Additional check:  Memory of canisters should be going up.  Memory should be non-zero.
# At least the registry canister should have memory.  Or make a query to the registry canister.
# Maybe ask for topology.  (child nns) It should come back but withhout nodes.

step 6 NNS Sanity checks || time (
    set_verbosity
    echo "This step does not actually perform any change: its just to make sure the child NNS is has sane permissions."
)

step 6.A Proposal submission without special identity. || time (
    set_verbosity
    unspecial_identity=666
    if ic-admin --nns-url "$child_nns_url" propose-to-bless-replica-version "$RELEASE_COMMIT" "$unspecial_identity"; then
        printf "ERROR: %s\n" \
            "Proposal submission without special identity should fail"
    else
        echo "SUCCESS: Unauthorized proposal submission was rejected"
    fi
)

step 6.B Proposal submission with IC op identity. || time (
    set_verbosity
    : "Identify path (download if needed) to the ${NETWORK}_admin_key.pem in the IC Support Team 1password vault. Now call:"

    # Shellcheck suspects that the '${..}' in the sed script is meant to be expanded by bash.  Not so.
    # shellcheck disable=SC2016
    proposal_id="$(ic-admin \
        -s "$IC_SUPPORT_KEY_FILE" \
        --nns-url "$child_nns_url" \
        propose-to-bless-replica-version "$RELEASE_COMMIT" "$IC_SUPPORT_NEURON_INDEX" | tee /dev/stderr | sed -nr '${s/^proposal\s+([0-9]+)$/\1/;ta;b;:a;p}' | grep .)"

    test -n "$proposal_id"

    : "Decline this proposal so it doesn't clog up the log files."
    : cd "$GIT_ROOT/rs/nns"
    : dfx --identity "${SUPER_LEADER}" canister --no-wallet --network="bootstrap_${NETWORK}" call governance manage_neuron --type=idl "(record {id=opt record {id=${SUPER_LEADER_NEURON_INDEX}}; command=opt variant {RegisterVote=record {vote=variant{No}; proposal=opt record {id=${proposal_id}}}}})"
)

step 6.C Check that you cannot delete nodes without special privileges || time (
    set_verbosity
    echo Registry mutation without special identity:
    network_file="$(record_network_topology_from_url "$child_nns_url")"
    some_node_id="$(jq <"$network_file" -r '.topology.subnets|map(.records)|flatten|map(.value.membership)|flatten|join("\n")' | sort -R | head -n1)"
    if ic-admin --nns-url "$child_nns_url" delete-node "$some_node_id"; then
        printf "ERROR: %s\n" \
            "Permissions are too loose." \
            "Deleting a node should not be permitted without special privileges"
        exit 1
    else
        echo "SUCCESS: Unauthorised node removal was rejected"
    fi
)

step 6.D Do a Registry mutation with the IC op identity, which is NOT whitelisted for registry mutation. || time (
    : "TODO: This fails at the client so it doesn't test the server"
    set_verbosity
    network_file="$(record_network_topology_from_url "$child_nns_url")"
    some_node_id="$(jq <"$network_file" -r '.topology.subnets|map(.records)|flatten|map(.value.membership)|flatten|join("\n")' | sort -R | head -n1)"
    if ic-admin -s "$IC_SUPPORT_KEY_FILE" --nns-url "$child_nns_url" delete-node "$some_node_id"; then
        printf "ERROR: %s\n" \
            "Permissions are too loose." \
            "The IC_SUPPORT_KEY_FILE is not authorized to delete nodes but managed to do so."
    else
        echo "SUCCESS: Computer said no."
    fi
)

step 7 Upgrade child NNS || true

: The new image is available at:
UPGRADE_COMMIT="${UPGRADE_COMMIT:-$RELEASE_COMMIT}"
UPGRADE_SUBNET="${UPGRADE_SUBNET:-0}"
: TODO: Update step 9 to use UPGRADE_COMMIT

step 7.A Make sure that we have the network admin key || time (
    set_verbosity
    : "Identify path (download if needed) to the ${NETWORK}_admin_key.pem in the IC Support Team 1password vault. This will be used to submit proposals."
    test -f "$IC_SUPPORT_KEY_FILE"
)

step 7.B Bless a replica version || true

step 7.B.0 Get artefacts || time (
    : "Get artefacts.  We do not need the boot image here."
    : "TODO : disable auth"
    sed 's/true/false/g' "$GIT_ROOT/.rclone.conf" >"$results_dir/.rclone-noauth.conf"
    download_dir="$results_dir/upgrade_artefacts"
    rm -fr "${download_dir:-THIS-IS-NOT-THE-DIR-YOU-ARE-LOOKING-FOR}"
    mkdir "$download_dir"
    rclone --config "$results_dir/.rclone-noauth.conf" --progress copyto "public-s3:dfinity-download/blessed/ic/$RELEASE_COMMIT/" "$download_dir"
)

step 7.B.1 Get the version of the upgrade image || time (
    set_verbosity
    set -eux
    image_with_placeholder_version="${results_dir}/upgrade_artefacts/guest-os/update-img/update-img.tar.gz"
    image_with_actual_version="${results_dir}/upgrade_artefacts/guest-os/update-img/update-img-versioned.tar.gz"

    OUT="${results_dir}/image_manipulation"
    rm -fr "${OUT:-THIS-IS-NOT-THE-DIR-YOU-ARE-LOOKING-FOR}"
    mkdir "$OUT"
    cd "$OUT"
    set -x
    ls -anh "$image_with_placeholder_version"
    tar -tf "$image_with_placeholder_version"
    tar -xf "$image_with_placeholder_version"
    # Check current file number in image
    current_version="$(echo "cat /opt/ic/share/version.txt" | debugfs root.img -f -)"
    if [[ "$current_version" == "$UPGRADE_COMMIT" ]]; then
        TODO: This step is no longer needed as the version is already correct.
    fi
    echo -n "$UPGRADE_COMMIT" >version.txt
    cat <<-EOF | debugfs root.img -w -f -
		cd /opt/ic/share
		rm version.txt
		write version.txt version.txt
	EOF
    echo "cat /opt/ic/share/version.txt" | debugfs root.img -f -
    rm version.txt
    tar -czf "$image_with_actual_version" --sparse .
    tar -tf "$image_with_actual_version"
    ls -anh "$image_with_actual_version"
)

step 7.B.2 Upload the versioned upgrade image || time {
    aws s3 cp "${results_dir}/upgrade_artefacts/guest-os/update-img-versioned.tar.gz" "s3://dfinity-download/ic/${UPGRADE_COMMIT}/guest-os/update-img-versioned.tar.gz"
}

step 7.B.5 Propose to bless || time (
    set_verbosity
    : "TODO Use download.dfinity.systems"
    : "TODO: Where else do we need to hash"

    SHA256="$(sha256sum "${results_dir}/upgrade_artefacts/guest-os/update-img-versioned.tar.gz" | awk '{print $1}')"

    export UPGRADE_URL="https://dfinity-download.s3-eu-central-1.amazonaws.com/ic/${UPGRADE_COMMIT}/guest-os/update-img-versioned.tar.gz"
    ic-admin \
        --nns-url "${child_nns_url}" \
        -s "$SUPER_LEADER_KEY_FILE" \
        propose-to-bless-replica-version-flexible \
        "$UPGRADE_COMMIT" \
        ignored ignored \
        ignored ignored \
        "$UPGRADE_URL" "$SHA256" \
        "$SUPER_LEADER_NEURON_INDEX"
)

step 7.B.6 Verify blessing || time (
    set_verbosity
    : TODO: Probably need a wait loop.
    ic-admin --nns-url "$child_nns_url" get-blessed-replica-versions | grep -q "$UPGRADE_COMMIT"
)

step 7.K Upgrade child NNS || true

step 7.K.1 "Propose to upgrade the child subnet number $UPGRADE_SUBNET" || time (
    set_verbosity
    proposal_id="$(
        ic-admin \
            -s "$SUPER_LEADER_KEY_FILE" \
            --nns-url "$child_nns_url" \
            propose-to-update-subnet-replica-version "$UPGRADE_SUBNET" "$UPGRADE_COMMIT" \
            "$SUPER_LEADER_NEURON_INDEX" \
            | tee /dev/stderr | sed -nr '${s/^proposal\s+([0-9]+)$/\1/;ta;b;:a;p}' | grep .
    )"
    setvar PROPOSAL_TO_UPGRADE_CHILD_NNS "$proposal_id"
)

step 7.K.3 Verify that votes have gone in || time (
    set_verbosity
    wait_for_proposal_approval "$NETWORK" "$PROPOSAL_TO_UPGRADE_CHILD_NNS"
)

step 7.K.4 Execute the proposal || time (
    set_verbosity
    cd "$GIT_ROOT/rs/nns"
    dfx --identity "$IC_SUPPORT" canister --no-wallet --network "$NETWORK" call governance execute_eligible_proposals
)

step 7.K.5 Wait for execution || time (
    set_verbosity
    wait_for_proposal_execution "${NETWORK}" "$PROPOSAL_TO_UPGRADE_CHILD_NNS"
)

step 7.K.6 "Verify that the correct code appears in the registry" || time (
    set_verbosity
    for ((retries = 100; retries >= 0; retries--)); do
        actual_code="$(ic-admin --nns-url "$child_nns_url" get-subnet "$UPGRADE_SUBNET" | jq -r '.records | map(.value.replica_version_id) | join("\n")')"
        printf "\rExpected: %32s  Actual: %32s  Retries: %5d" "$UPGRADE_COMMIT" "$actual_code" "$retries"
        if [[ "$actual_code" == "$UPGRADE_COMMIT" ]]; then
            printf "\nOK\n"
            break
        elif ((retries > 0)); then
            sleep 1
        else
            printf "ERROR: %s\n" \
                "The replica_version_id has not been upgraded to the expected value" \
                "Expected:    $UPGRADE_COMMIT" \
                "Actual:      $actual_code"
            exit 1
        fi
    done
)

# TODO: Curl an upgraded child node instead.
# There was code to pick a child node.  Where is it now?
step 7.L Wait for the impl_version to be the release commit || time (
    set_verbosity
    for ((retries = 100; ; retries--)); do
        expected="$UPGRADE_COMMIT"
        actual="$(curl -s --output - "${child_nns_url}/api/v2/status" | cbor2diag.rb | sed -nr 's/.*"impl_version": "([^"]*)".*/\1/g;ta;b;:a;p' || echo Broken CBOR)"
        printf "\r Expected: %32s  Actual: %32s  (%3d retries left)                " "$expected" "$actual" "$retries"
        if [[ "$expected" == "$actual" ]]; then
            printf "\nOK\n"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            printf "\n\nERROR: TIMEOUT: Expected state not reached.\n"
            exit 1
        fi
    done
)

step 8 Register all app nodes || {
    echo "Note: This step has to be repeated with DEPLOY_INDEPENDENT_NODES set for production-like deployments."
}

step 8.A Prepare || true

step 8.A.0 Destroy existing guests || (
    set_verbosity
    cd "$GIT_ROOT/testnet"
    /usr/bin/ansible-playbook ansible/roles/ic_guest_prod/playbook.yml -i "env/$NETWORK/metal_hosts" --limit "child_app_*_hosts${DEPLOY_INDEPENDENT_NODES:+_lockout}" -e ic_state=destroy --user terraform
)

step 8.A.1 Record parent node principals || (
    set_verbosity
    parent_node_principals_file="${results_dir}/parent_node_principals"
    setvar parent_node_principals_file "$parent_node_principals_file"
    ic-admin --nns-url "$parent_nns_url" get-topology | jq -r '.topology.subnets | values[] | .records | map(.value.membership) | .[] | .[]' >"$parent_node_principals_file"
    echo "Parent node principals are recorded here: $parent_node_principals_file"
)

step 8.A.2 Record the operators node allowance before deployment || time (
    set_verbosity
    setvar total_node_operator_allowance "$(get_node_operator_allowances "$child_nns_url")"
    echo "Total operators node allowance: $total_node_operator_allowance"
)

step 8.B Create child_nns configuration media image || true

step 8.B.1 Get the ssh keys || (
    set_verbosity
    rm -fr "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}"
    cp -R "$GIT_ROOT/testnet/env/${NETWORK}/ssh_keys" "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}"
)

step 8.B.2 Get the child NNS public key || (
    set_verbosity
    rm -f "$results_dir/child_nns_public_key.pem"
    ic-admin --nns-url "${child_nns_url}" get-subnet-public-key 0 "$results_dir/child_nns_public_key.pem"
)

step 8.B.3 Verify that inputs are present || (
    set_verbosity
    set -eux
    test -e "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}/admin"
    test -e "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}/readonly"
    test -e "$results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}/backup"
    test -e "$results_dir/child_nns_public_key.pem"
)

step 8.B.4 Create the config media image || (
    set_verbosity
    set -eux
    cd "$GIT_ROOT/ic-os/guestos/"
    : enter nix shell - or command - nix.
    rm -fr "${results_dir:-THIS-IS-NOT-THE-DIRECTORY-YOU-ARE-LOOKING-FOR}/child_config${DEPLOY_INDEPENDENT_NODES:+_lockout}"
    mkdir "$results_dir/child_config${DEPLOY_INDEPENDENT_NODES:+_lockout}"
    nix-shell --command "
        ./scripts/build-bootstrap-config-image.sh $results_dir/child_config${DEPLOY_INDEPENDENT_NODES:+_lockout}/media.img --accounts_ssh_authorized_keys $results_dir/ssh_keys${DEPLOY_INDEPENDENT_NODES:+_lockout}/ --nns_url $child_nns_url --nns_public_key $results_dir/child_nns_public_key.pem "
)

step 8.C "Verify that HSMs are present in the child_app bare metal hosts" || time (
    set_verbosity

    test -z "${DEPLOY_INDEPENDENT_NODES:-}" || {
        echo skipping for independent nodes
        exit 0
    }

    if ansible -i "env/$NETWORK/metal_hosts" "child_app_*_hosts" -m shell -a "lsusb | grep -E 'Nitro|Clay'"; then
        echo "All HSMs present"
    else
        cat <<-EOF
			Some HSMs were absent.  Please reconnect them, now or after deployment.
		EOF
    fi
)

step 8.D "Create child_app guest domains" || time (
    set_verbosity
    cd "${GIT_ROOT}/testnet"
    /usr/bin/ansible-playbook ansible/roles/ic_guest_prod/playbook.yml \
        -i "env/$NETWORK/metal_hosts" \
        --limit "child_app_*_hosts${DEPLOY_INDEPENDENT_NODES:+_lockout}" \
        --user terraform \
        -e ic_state=create -e ic_disk_sha="$RELEASE_COMMIT" \
        -e ic_media_path="$results_dir/child_config${DEPLOY_INDEPENDENT_NODES:+_lockout}/" \
        -e ic_deployment_name="$NETWORK"
)

step 8.E "Start child_app  guest domains" || time (
    set_verbosity
    test -z "${DEPLOY_INDEPENDENT_NODES:-}" || exit 0
    cd "${GIT_ROOT}/testnet"
    /usr/bin/ansible-playbook ansible/roles/ic_guest_prod/playbook.yml \
        -i "env/$NETWORK/metal_hosts" \
        --limit "child_app_*_hosts${DEPLOY_INDEPENDENT_NODES:+_lockout}" \
        --user terraform \
        -e ic_state=start
)

step 8.F "Verify that app nodes are registered in the child NNS as unassigned" || time (

    set_verbosity

    guest_facts_filter="groups=child_app_[0-9]+_hosts${DEPLOY_INDEPENDENT_NODES:+_lockout}"
    network_file="$(record_network_topology_from_url "$child_nns_url")"
    echo "Topology:    $network_file"
    echo "Guest facts: ${results_dir}/guest_facts"

    for ((retries = 100; ; retries--)); do
        record_network_topology_from_url "$child_nns_url"
        # Get ip addresses of all nodes known to the child nns.
        "${GIT_ROOT}/launch/get_node_principal_ips" "$child_nns_url" >"$results_dir/child-node-principal-ips-2" \
            && mv "$results_dir/child-node-principal-ips-2" "$results_dir/child-node-principal-ips"
        # Compile guest facts, including the principal where known.
        "${GIT_ROOT}/launch/compute_guest_facts" <"${results_dir}/metal_facts" >"${results_dir}/guest_facts-2" \
            && mv "${results_dir}/guest_facts-2" "${results_dir}/guest_facts"
        # Check whether all the deployed nodes have principals.
        num_unassigned="$(cat "${results_dir}/guest_facts" \
            | grep -wE "guest_facts_filter" \
            | grep -vE 'principal=[a-zA-Z0-9]' \
            | wc -l || true)"
        # Check that the nodes are unassigned
        : TODO "capture the subnet allocation, if any, as part of the guest_facts"
        # Report on progress, and loop if not all nodes have registered.
        printf "\r Waiting for: %3d  Retries left: %3d" "$num_unassigned" "$retries"
        if ((num_unassigned == 0)); then
            printf "\nOK\n"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            printf "ERROR: %s\n" \
                "REGISTRATION ERROR" \
                "All app nodes should have registered with the child NNS and should have principals." \
                "These don't:" \
                >&2
            grep <"${results_dir}/guest_facts" -wE "$guest_facts_filter" >&2
            exit 1
        fi
    done
)

step 8.G Record the operators node allowance after deployment || time (
    last_total="${total_node_operator_allowance:-0}"
    setvar total_node_operator_allowance "$(get_node_operator_allowances "$child_nns_url")"
    echo "Total operators node allowance: $total_node_operator_allowance"
    echo "Delta:                          $((total_node_operator_allowance - last_total))"
)

step 8.H "Sleep - always necessary even if it doesn't seem to be" || time (
    sleep 2m
)

APP_SUBNET_NUMBER="${APP_SUBNET_NUMBER:-1}"
step 9 "Create app subnet, for every APP_SUBNET_NUMBER=1..n" || true

step 9.A "Make sure that guest facts are up to date" || time (
    # Get ip addresses of all nodes known to the child nns.
    "${GIT_ROOT}/launch/get_node_principal_ips" "$child_nns_url" >"$results_dir/child-node-principal-ips-2" \
        && mv "$results_dir/child-node-principal-ips-2" "$results_dir/child-node-principal-ips"
    # Compile guest facts, including the principal where known.
    "${GIT_ROOT}/launch/compute_guest_facts" <"${results_dir}/metal_facts" >"${results_dir}/guest_facts-2" \
        && mv "${results_dir}/guest_facts-2" "${results_dir}/guest_facts"
)

step 9.G "Create app subnet" || true

step 9.G.2 Propose the creation of a subnet || time (
    set_verbosity
    network_file="$(record_network_topology_from_url "$child_nns_url")"
    NEW_NODE_IDS="$(grep <"${results_dir}/guest_facts" -E "groups=child_app_${APP_SUBNET_NUMBER}_hosts" \
        | while read line; do (
            eval entry=$line
            echo $principal
        ); done)"
    # NEW_NODE_IDS is meant to expand to multiple arguments
    # shellcheck disable=SC2086
    setvar PROPOSAL_TO_CREATE_CHILD_SUBNET "$(
        ic-admin -s "$SUPER_LEADER_KEY_FILE" \
            --nns-url "$child_nns_url" \
            propose-to-create-subnet \
            --proposer "${SUPER_LEADER_NEURON_INDEX}" \
            --subnet-handler-id "unused" \
            --ingress-bytes-per-block-soft-cap 2097152 \
            --max-ingress-bytes-per-message 2097152 \
            --max-ingress-messages-per-block 1000 \
            --unit-delay-millis 2000 \
            --initial-notary-delay-millis 2500 \
            --dkg-interval-length 99 \
            --gossip-max-artifact-streams-per-peer 20 \
            --gossip-max-chunk-wait-ms 15000 \
            --gossip-max-duplicity 1 \
            --gossip-max-chunk-size 4096 \
            --gossip-receive-check-cache-size 5000 \
            --gossip-pfn-evaluation-period-ms 3000 \
            --gossip-registry-poll-period-ms 3000 \
            --gossip-retransmission-request-ms 60000 \
            --subnet-type ${APP_SUBNET_TYPE:-application} \
            $NEW_NODE_IDS \
            | tee /dev/stderr | sed -nr '${s/^proposal\s+([0-9]+)$/\1/;ta;b;:a;p}' | grep .
    )"
)

step 9.G.3 "Wait for votes" || time (
    set_verbosity
    wait_for_proposal_approval "$NETWORK" "$PROPOSAL_TO_CREATE_CHILD_SUBNET"
)

step 9.G.4 Execute proposal || time (
    set_verbosity
    ic-admin --nns-url "$child_nns_url" execute-eligible-proposals
)

step 9.G.5 "Wait for the proposal execution to complete" || time (
    set_verbosity

    echo
    echo
    echo "Waiting is boring.  Watch the action on the NNS:"
    echo "    ansible -i env/$NETWORK/hosts -a "journalctl -n1000 -u dfinity-node.service" nns"
    echo
    echo

    wait_for_proposal_execution "$NETWORK" "$PROPOSAL_TO_CREATE_CHILD_SUBNET"
)

step 9.G.6 "Check the topology to see that the number of subnets is as expected" || time (
    set_verbosity
    expected_num_subnets=$((1 + APP_SUBNET_NUMBER)) # nns and this newly created app_subnet
    for ((retries = 100; ; retries--)); do
        network_file="${results_dir}/${STEP}-${APP_SUBNET_NUMBER}-topology"
        ic-admin --nns-url "$child_nns_url" get-topology >"$network_file"
        num_subnets="$(jq <"$network_file" '.topology.subnets | length')"
        printf '\r Have %d subnets.  Waiting for %d with %3d tries left' "$num_subnets" "$expected_num_subnets" "$retries"
        if ((expected_num_subnets == num_subnets)); then
            break
        elif ((retries > 0)); then
            sleep 1
        else
            echo
            printf "ERROR: %s\n" \
                "Incorrect number of subnets" \
                "Expected nns and app subnets, hence $expected_num_subnets" \
                "Actual num subnets: $num_subnets"
            exit 1
        fi
    done
    # TODO: It would be nice to know which of those keys is app_subnet and so verify the membership.
    # E.g. in this run, the membership is 1 less than expected because one node has no HSM.
)

step 9.G.7 "Update guest facts" || time (
    # Get ip addresses of all nodes known to the child nns.
    "${GIT_ROOT}/launch/get_node_principal_ips" "$child_nns_url" >"$results_dir/child-node-principal-ips-2" \
        && mv "$results_dir/child-node-principal-ips-2" "$results_dir/child-node-principal-ips"
    # Compile guest facts, including the principal where known.
    "${GIT_ROOT}/launch/compute_guest_facts" <"${results_dir}/metal_facts" >"${results_dir}/guest_facts-2" \
        && mv "${results_dir}/guest_facts-2" "${results_dir}/guest_facts"
)

step 9.G.8 "Wait until the newly added app nodes are up and running" || time (
    set_verbosity
    failure_file="${results_dir}/${STEP}-${APP_SUBNET_NUMBER}-failures"
    echo "The addresses we are waiting for: $failure_file"
    filter="groups=child_app_${APP_SUBNET_NUMBER}_hosts"
    function all_ok() {
        local failures="$(grep -E "$filter" "$results_dir/guest_facts" \
            | grep 'principal=[a-zA-Z0-9]' \
            | sed -nr 's/.*ipv6=(\S+).*/\1/g;ta;b;:a;p' \
            | while read -r ipv6; do is_live_ipv6 "$ipv6" >/dev/null || echo "$ipv6"; done \
            | tee "${failure_file}")"
        test -z "${failures:-}"
    }
    for ((retries = 100; ; retries--)); do
        printf "\rTries left: %3d" "$retries"
        if all_ok 2>/dev/null; then
            printf "\n\nOK\n"
            grep -E "$filter" "$results_dir/guest_facts" \
                | grep 'principal=[a-zA-Z0-9]' \
                | sed -nr 's/.*ipv6=(\S+).*/\1/g;ta;b;:a;p' \
                | xargs -I{} echo "http://[{}]:8080/_/dashboard"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            printf "ERROR: %s\n" \
                "Timeout waiting for child_app_${APP_SUBNET_NUMBER}_hosts to come up"
            all_ok
            exit 1
        fi
    done
)

step 10 Deploy IC-FE || true

step 10.A Make sure that Prometheus has ipv4 connectivity to all the hosts that will make up the network || true

stats_port=9091

step 10.A.1 "Make sure that Prometheus can ping all the hosts that will make up the network" || time (
    set_verbosity
    : "Ping doesn't tell all but until the service is installed we can't check the TCP connection."
    ansible_data "env/$NETWORK/parent_hosts" nns:subnets .ipv6 | xargs -I{} ansible -i "env/${NETWORK}/hosts" prometheus -a "ping -6 -c3 {}"
)
step 10.A.2 "Make sure that all the hosts have stats available on port $stats_port" || time (
    set_verbosity
    ansible -i "env/${NETWORK}/hosts" nns:subnets -a "bash -c 'curl --fail --silent localhost:$stats_port >/dev/null && echo SUCCESS || { echo FAIL ; exit 1 ; }'"
)
step 10.A.3 "Make sure that Prometheus can access the stats port on all the nodes" || time (
    set_verbosity
    ansible_data "env/$NETWORK/parent_hosts" nns:subnets .ipv6 | xargs -I{} ansible -i "env/${NETWORK}/hosts" prometheus -a "bash -c 'curl --fail --silent \"http://[{}]:$stats_port\" >/dev/null && echo SUCCESS {} || { echo FAIL {} ; exit 1 ; }'"
)

step 10.C Update prometheus network || time (
    set_verbosity
    ansible-playbook -vv -i "env/$NETWORK/hosts" ic_p8s_network_update.yml -e yes_i_confirm=yes
)

step 10.D Scan 1.2.3.4/0 for new nodes - jk || time (
    set_verbosity
    ansible-playbook -vv -i "env/$NETWORK/hosts" ic_p8s_service_discovery_install.yml -e yes_i_confirm=yes
)

step 10.E Make sure that Prometheus is accessing nodes on the network || time (
    set_verbosity

    for ((retries = 100; ; retries--)); do

        endpoints_currently_up="$results_dir/$STEP-endpoints_currently_up.txt"
        endpoints_for_this_network="$results_dir/$STEP-endpoints_for_this_network.txt"
        missing_endpoints="$results_dir/$STEP-missing-endpoints.txt"

        curl "http://prometheus.dfinity.systems:9090/api/v1/query?query=up" | jq -r '.data.result | map(select(.value[1]=="1")) | map(.metric.instance) | join("\n")' | sort >"$endpoints_currently_up"
        ansible_data "env/$NETWORK/hosts" nns:subnets .ipv6 | sed 's/.*/[&]:9090/g' | sort >"$endpoints_for_this_network"
        grep -vxFf "$endpoints_currently_up" "$endpoints_for_this_network" >"$missing_endpoints" || true

        printf "Written file %-30s %s\n" \
            endpoints_currently_up: "$endpoints_currently_up" \
            endpoints_for_this_network: "$endpoints_for_this_network" \
            missing_endpoints: "$missing_endpoints"

        num_missing_nodes="$(wc -l <"$missing_endpoints")"

        printf '\r Num missing nodes%12s  with %3d tries left' "$num_missing_nodes" "$retries"
        if ((0 == num_missing_nodes)); then
            printf '\n\nOK\n\n'
            break
        elif ((retries > 0)); then
            sleep 10
        else
            echo
            printf "ERROR: %s\n" \
                "Prometheus cannot see some endpoints." \
                "To verify that Prometheus can access a port:" \
                "ansible -i env/${NETWORK}/hosts prometheus -a 'nc -z -w5 NODE_IP_ADDRESS 9090'"
            exit 1
        fi
    done

)

echo
finaltime="$(date '+%s')"
duration=$((finaltime - starttime))
echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed in total in this test."
echo "This bootstrap test was called with the following arguments"
echo "$@"

test -z "${STEPS:-}" || ((NUM_STEPS_MATCHED)) || {
    printf "ERROR: %s\n" \
        "NO STEPS MATCHED THE PATTERN '$STEPS'"
}
