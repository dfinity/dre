#!/usr/bin/env bash

# This is the bootstrap script, used to deploy replicas from scratch at launch.
#
# Roughly speaking, this script:
# 1. sets up a dfinity-owned nns
# 2. registers x independent nodes to extend the root nns (This extended nns is called the "parent_nns")
# 3. registers y independent nodes to create a child_nns, with keys generated by all nodes in the parent_nns.  (A single honest parent node is enough to make the key generation of the child nns unguessable).
# 4. installs nns canisters on child nns
# 5. registers z independent nodes to create an application subnet.  This step may be repeated as often as required
# 6. adds monitoring for all the nodes on the network.

# Shellcheck exemption:
# We use subshells to isolate code.  Shellcheck is concerned that changes are meant to be global.
# shellcheck disable=SC2030,SC2031,SC2154
# We use sed a lot, but shellcheck is worried about '$' not expanding to  avaraible.
# shellcheck disable=SC2016
: End shellcheck global rules

set -euo pipefail

# trap on errors in called functions or subshells
set -o errtrace
set -o functrace

err_report() {
    echo "ERROR: ($1) on line $2"
}

trap 'err_report $? $LINENO' ERR

while (($# > 0)); do
    case "$1" in
        -h | --help)
            # Note: The text must be indented with tabs for an indented heredoc.
            cat <<-EOF


			Bootstraps a testnnet.

			Usage:  $0 [flags] <testnet_identifier> <results_dir>

			Flags:

			    -d|--dry-run = Print the steps but do not execute them. (env: set DRY_RUN)

			    -n|--network = The name of the network. (env: NETWORK=value)

			    -o|--output-dir = Where to write the results. (env: OUTPUT_DIR=value)

			    -v|--verbose = Set -x within the step. (env: set VERBOSE)

			    --app-node-limit = Ansible filter for app nodes (env: set APP_NODE_LIMIT)

			Env vars:

			    STEPS = a regex matching the steps to run.  Steps have labels such
			        as 0.A.3 or 1.B.5.c.  If the regex matches the prefix, the
			        step will be executed.  Default:  Run all non-optional steps.

			    HSM_MODULE = path to the HSM module to use.  Examples:
			        SoftHSM on Ubuntu-20:       /usr/lib/x86_64-linux-gnu/softhsm/libsofthsm2.so
			        Nitrokey HSM on Ubuntu-20:  /usr/lib/x86_64-linux-gnu/opensc-pkcs11.so
			        Nitrokey HSM on OsX:        Not needed

			    Note: HSM refers to the master HSM, by default, but this isn't essential.
			    HSM_SLOT     = HSM slot number - otherwise the first slot with HSM in the title will be used.
			    HSM_PIN_FILE = File containing the pin to access the HSM; CI should use TEST PINS ONLY.
			    HSM_KEY_ID   = Key ID of the master key

			    GIT_REVISION = commit of build artifacts to use.  Default:  Current commit.
		EOF
            exit 0
            ;;
        -d | --dry*)
            shift 1
            DRY_RUN=very_dry
            ;;
        -n | --network)
            export NETWORK="$2"
            shift 2
            ;;
        -o | --output-dir)
            results_dir="$2"
            shift 2
            ;;
        -v | --verbose)
            shift 1
            VERBOSE=garrulous
            ;;
        --app-node-limit)
            APP_NODE_LIMIT="$2"
            shift 2
            ;;
        *)
            if (($# == 1)); then
                STEPS="$1"
                break
            else
                printf "ERROR: %s\n" "Unsupported argument: $1" >&2
                exit 1
            fi
            ;;
    esac
done

results_dir="${OUTPUT_DIR:-$TMPDIR/bootstrap-$NETWORK}"
REPO_ROOT="${REPO_ROOT:-$(git rev-parse --show-toplevel)}"
REPO_ROOT_IC="${REPO_ROOT_IC:-$(git worktree list --porcelain | grep worktree | cut -b10- | head -n1)/ic}"
ENV_DIR="${ENV_DIR:-$REPO_ROOT/deployments/env/$NETWORK}"
DKG_INTERVAL_LENGTH="${DKG_INTERVAL_LENGTH:=-1}"
ALL_ARTIFACTS="$HOME/all-artifacts/"

unset NODES_FILTER_INCLUDE

test -n "${results_dir:-}" || {
    printf "ERROR: %s\n" \
        "Output dir not specified." \
        "Please use the flag: -o <DIR>" >&2
    exit 1
}
test -d "$(dirname "${results_dir}")" || {
    printf "ERROR: %s\n" \
        "Output dir is not a directory:" \
        "'$results_dir'" >&2
    exit 1
}
test -n "${NETWORK:-}" || {
    printf "ERROR: %s\n" \
        "Network not specified." \
        "Please use the flag: -n <NETWORK>" >&2
    exit 1
}
test -d "$ENV_DIR" || {
    printf "ERROR: %s\n" \
        "ENV_DIR $ENV_DIR does not exist. These networks are defined:" \
        "$(find "$ENV_DIR" -maxdepth 1 -type d | xargs -I{} basename "{}" | tr "\n" " ")" >&2
    exit 1
}

if [[ ! -d "$ENV_DIR" ]]; then
    echo >&2 "'$ENV_DIR' doesn't exist, aborting."
    exit 1
fi

if [[ ! -d $results_dir ]]; then
    echo >&2 "'$results_dir' does not exist, will be created..."
fi

if [[ $results_dir != /* ]]; then
    echo >&2 "'$results_dir' is not an absolute path, converting to absolute..."
    results_dir="$PWD/$results_dir"
fi

echo "Starting bootstrap test on network with identifier $NETWORK."

# Helper function to convert times
dateFromEpoch() {
    if [[ "$(uname)" == "Darwin" ]]; then
        date -j -f '%s' "$1"
    else
        date --date="@$1"
    fi
}

# Store the test start time in epoch, so we could query Prometheus later.
starttime="$(date '+%s')"
echo "Testcase start time: $(dateFromEpoch "$starttime")"

cd "$ENV_DIR"

ARCH="$(if uname | grep -q Darwin; then echo -n x86_64-darwin; else echo -n x86_64-linux; fi)"
export ARCH

# Requirements:
# - Make it clear which commands have a side-effect in the shell
#   - Done by running side-effect free commands in a subshell () vs {}.
# - Run just some commands
STEPS_PATTERN="^(${STEPS:-.*})([.].*|$)"
ENV_FILE="${results_dir}/env_vars"
BIN_DIR="${results_dir}/bin"

echo ENV_FILE = "$ENV_FILE"
NUM_STEPS_MATCHED=0
step() {
    # Runs a named step if the name matches the env var STEPS.
    # Optional steps are skipped unless STEPS matches the step name exactly.
    if [[ "$1" == "--optional" ]]; then
        local optional="1"
        shift 1
    else
        local optional=""
    fi
    STEP="$1"
    if [[ "$STEP" =~ $STEPS_PATTERN ]]; then
        ((NUM_STEPS_MATCHED++))
        test -n "${DRY_RUN:-}" || printf "\n\n"
        echo "#$(echo "$1" | tr -cd '.' | tr . '#')${optional:+ (Optional)} $*"
        test -e "$ENV_FILE" || touch "$ENV_FILE"
        # shellcheck disable=SC1090
        source "$ENV_FILE"
        # Nothing more to do if:
        #    this is a dry run
        # OR the step is optional and doesn't match the filter exactly.
        if test -n "${DRY_RUN:-}" || { test -n "${optional:-}" && [[ "$STEP" != "${STEPS:-}" ]]; }; then
            echo "Skipping step $STEP"
        else
            echo "Step $STEP start: $(date -u --rfc-3339=seconds)"
            false
        fi
    else
        true
    fi
}

# Function to preserve vars to be used over multiple steps, so that they are still there if the shell is killed.
setvar() {
    printf 'export %s=%q\n' "$1" "$2" >>"$ENV_FILE"
    # Shellcheck cannot find this file.  that is OK, as it is created afresh for each run.
    # shellcheck disable=SC1090
    source "$ENV_FILE"
}

set_verbosity() {
    test -z "${VERBOSE:-}" || set -x
}

load_pin() {
    HSM_PIN="$(sed -n 1p "$HSM_PIN_FILE" | tr -cd '0-9')"
    export HSM_PIN
    export DFX_HSM_PIN="$HSM_PIN"
}

record_network_topology_from_url() {
    (
        set -eu
        nns_url="$1"
        label="${2:-}"
        network_file="$results_dir/$STEP${label:+-$1}-network-topology.json"
        if ic-admin --nns-url "$nns_url" get-topology | jq >"$network_file"; then
            echo "Network topology written to: $network_file" >&2
            echo "$network_file"
        else
            echo "Failed to get the network topology"
        fi
    )
}

is_live_ipv6() {
    ipv6="$1"
    curl --fail --silent --connect-timeout 2 http://[${ipv6}]:8080/api/v2/status >/dev/null 2>/dev/null
}

# Status is no longer provided so we need to deduce it
parse_status() {
    awk 'BEGIN{state="Accepted"}(($1=="executed_timestamp_seconds")&&($3 != 0)){state="AcceptedAndExecuted"}(($1=="tally_at_decision_time")&&($3=="null")){status="Open"}END{print(status)}'
}

wait_for_proposal_approval() {
    (
        local NETWORK="$1"
        local PROPOSAL="$2"
        cd "$REPO_ROOT/scripts/staging/canisters"

        expected="true"
        status_file="${results_dir}/${NETWORK}-proposal-${PROPOSAL}.idl"
        printf "\nWaiting for the proposal to be approved\nStatus in: %s\n\n" "$status_file"
        for ((retries = 100; ; retries--)); do
            # Wait until time has been spent on execution.
            state="$(dfx --identity "${IC_SUPPORT}" canister --network="$NETWORK" call governance get_proposal_info "(${PROPOSAL}:nat64)" | tee "${status_file}" | idl2json | jq '.[0]|((.decided_timestamp_seconds|tonumber)>0) and ((.latest_tally[0].yes|tonumber)>(.latest_tally[0].total|tonumber)/2)')"
            printf '\r Expected state: %12s  Actual state: %12s  with %3d tries left' "$expected" "$state" "$retries"
            if [[ "$state" == "$expected" ]]; then
                printf '\n\nOK\n\n'
                break
            elif ((retries > 0)); then
                sleep 10
            else
                echo
                printf "ERROR: %s\n" \
                    "Proposal has not been accepted." \
                    "Expected state: $expected" \
                    "Actual state:   $state"
                exit 1
            fi
        done
    )
}

wait_for_proposal_execution() {
    (
        local NETWORK="$1"
        local PROPOSAL="$2"
        cd "$REPO_ROOT/scripts/staging/canisters"

        expected="true"
        status_file="${results_dir}/${NETWORK}-proposal-${PROPOSAL}.idl"
        printf "\nWaiting for the proposal to be executed\nStatus in: %s\n\n" "$status_file"
        for ((retries = 100; ; retries--)); do
            # Wait until time has been spent on execution.
            state="$(dfx --identity "${IC_SUPPORT}" canister --network="$NETWORK" call governance get_proposal_info "(${PROPOSAL}:nat64)" | tee "${status_file}" | idl2json | jq '(.[0].executed_timestamp_seconds|tonumber) > 0')"
            printf '\r Expected state: %12s  Actual state: %12s  with %3d tries left' "$expected" "$state" "$retries"
            if [[ "$state" == "$expected" ]]; then
                printf '\n\nOK\n\n'
                break
            elif ((retries > 0)); then
                sleep 10
            else
                echo
                printf "ERROR: %s\n" \
                    "Proposal has not been executed." \
                    "Expected state: $expected" \
                    "Actual state:   $state"
                exit 1
            fi
        done
    )
}

# Get data from ansible, without ssh.
ansible_data() {
    # Arguments:
    local deployment=$1                        # e.g. "bootstrap" or "disaster"
    local group="$2"                           # An ansible hostgroup such as 'nns' or 'subnets' or a combination as defined here: https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html
    local key="hostvars[inventory_hostname]$3" # A path into Ansible's hostvars (for which I cannot find a spec).

    # Print the requested variable, one line per entry, without quotes.
    # Note: We use debug to avoid ssh to nodes.
    ansible -m debug -a "var=$key" -i "$ENV_DIR/hosts" "$group" | sed -E 's/^[^{]* =>//g' | key="$key" jq '.[env.key]' | tr -d '"'
}

function guest_facts() {
    set -x
    $REPO_ROOT/factsdb/main.py --deployment $NETWORK --nns-url "${NNS_URL:-}" --guests "$@" 2>/dev/null
}

echo

# Note: The stage -1 steps are now not in Alpha 2.0 Runbook: https://docs.google.com/document/d/1Er2YuD0KNKkQ9EGdPVymqEEWpr9JEAOqHP5MscjIcJc/edit#
step -1 Destroy environment || true

step -1.A Destroy env || time (
    set_verbosity
    if test -d "${results_dir}"; then
        echo "INFO: Results dir ${results_dir} already exists. Moving to ensure a clean environment."
        (
            . "${results_dir}/env_vars" || true
            set -x
            mv -v "${results_dir}" "${results_dir}.${NETWORK:-}.$(date +%s)"
        )
    else
        echo "Created empty results dir: $results_dir"
        mkdir "$results_dir"
    fi
)

step -1.B Destroy the entire deployment || time (
    set -eu
    set_verbosity
    cd "$REPO_ROOT_IC/testnet/ansible"
    ansible -i "$ENV_DIR/hosts" nodes --list-hosts
    echo "Destruction is imminent. You may cancel by pressing Ctrl+C now."
    sleep 3
    ansible-playbook roles/ic_guest_prod/playbook.yml -i "$ENV_DIR/hosts" --limit "physical_hosts" \
        --extra-vars "ic_state=destroy" --extra-vars ansible_user=dfnadmin
)

step 0 Preparation || true

export PATH="$BIN_DIR:$PATH"
mkdir -p "$BIN_DIR"

# Always check disk and RAM on every run.
(
    min_ram_Gi=4
    min_disk_Gi=5
    case "$ARCH" in
        *-darwin)
            ram_available_Gi="$(df -h . | awk '(NR==2){print $4}' | xargs numfmt --from=auto --to-unit=Gi)"
            ;;
        *-linux)
            ram_available_Gi="$(free -g | awk '($1=="Mem:"){print $7}')"
            ;;
        *)
            printf "ERROR: %s\n" "Don't know how to get available RAM for arch $ARCH"
            exit 1
            ;;
    esac
    disk_available_Gi="$(df -h . | awk '(NR==2){print $4}' | xargs numfmt --from=auto --to-unit=Gi)"
    echo Checking disk space
    ((disk_available_Gi >= min_disk_Gi)) || {
        printf "ERROR: %s\n" "Insufficient free disk space to proceed safely." "Please delete files or use a larger drive." "You can proceed when you have ${min_disk_Gi}Gi bytes free."
        exit 1
    }
    echo Checking RAM
    ((ram_available_Gi >= min_ram_Gi)) || {
        printf "ERROR: %s\n" "Insufficient free RAM to proceed safely." "Please stop memory-hungry processes." "You can proceed when you have ${min_ram_Gi}Gi bytes free."
        exit 1
    }
)

step 0.A.0 "Prepare the deployment branch variables" || time (
    set_verbosity
    mkdir -p "${results_dir}"
    setvar GIT_REVISION "${GIT_REVISION:-$(git rev-parse HEAD)}"
    setvar REPO_ROOT "$REPO_ROOT"
    setvar ENV_DIR "$ENV_DIR"
    setvar NETWORK "$NETWORK"
    setvar results_dir "$results_dir"
    # TODO: Make sure to base the release on the release commit.
)

step 0.A.0.1 "Check that git is clean" || time (
    set_verbosity
    if git status --untracked-files=no --porcelain | grep .; then
        echo "WARNING: Git has unstaged changes."
    fi
)

step 0.A.0.3 "Check the super leader" || time (
    set_verbosity
    # Verify that the super-leader key file is present and correct
    SUPER_LEADER_KEY_FILE="${HOME}/.config/dfx/identity/${NETWORK}-super-leader/identity.pem"
    test -n "${SUPER_LEADER_KEY_FILE:-}" || {
        printf "ERROR: %s\n" \
            "SUPER_LEADER_KEY_FILE is not defined." \
            "The file can be found in the 1Pass vault."
        exit 1
    }
    # Verify that the key is present
    test -f "${SUPER_LEADER_KEY_FILE}" || {
        printf "ERROR: %s\n" \
            "SUPER_LEADER_KEY_FILE '$SUPER_LEADER_KEY_FILE' is not a file."
        exit 1
    }
    setvar SUPER_LEADER_KEY_FILE "$SUPER_LEADER_KEY_FILE"
)

step 0.A.0.4 "Check the ops key" || time (
    # TODO: In future we should have a separate ops key for each network, not use the IC_SUPPORT key that has additional privileges.
    # At the moment this is hard wired in ansible (probably).  needs to be injected when we bootstrap.
    set_verbosity
    # Verify that the ops key file is present and correct
    IC_SUPPORT_KEY_FILE="${HOME}/.config/dfx/identity/${NETWORK}-support/identity.pem"
    test -n "${IC_SUPPORT_KEY_FILE:-}" || {
        printf "ERROR: %s\n" \
            "IC_SUPPORT_KEY_FILE is not defined." \
            "The file can be found in the 1Pass vault."
        exit 1
    }
    # Verify that the key is present
    test -f "${IC_SUPPORT_KEY_FILE}" || {
        printf "ERROR: %s\n" \
            "IC_SUPPORT_KEY_FILE '$IC_SUPPORT_KEY_FILE' is not a file."
        exit 1
    }
    setvar IC_SUPPORT_KEY_FILE "$IC_SUPPORT_KEY_FILE"
)

step 0.A.0.7 "Check that the guest ssh keys are present" || time (
    dir="$ENV_DIR/ssh_keys_dfinity_nodes"
    test -d "$dir" || {
        echo "ERROR: The guest ssh keys should be in: $dir"
        exit 1
    }
    dir="$ENV_DIR/ssh_keys_external_nodes"
    test -d "$dir" || {
        echo "ERROR: The independent guest ssh keys should be in: $dir"
        exit 1
    }
)

step 0.A.2 "Populate dfx.json" || time (
    set_verbosity
    # Ensure canisters/dfx.json contains a '${NETWORK}' entry to be able to use dfx with the canisters

    dfx_file="$REPO_ROOT/scripts/staging/canisters/dfx.json"
    # TODO: Export NNS_HOST and BOOTSTRAP_NNS_HOST and replace parent_nns_host and child_nns_host.

    # Add the network
    NNS_HOST="$(ansible_data "$NETWORK" nns .ipv6 | head -n1)"
    NNS_URL="http://[${NNS_HOST}]:8080"
    export NNS_URL
    contents="$(jq --indent 2 '.networks["\(env.NETWORK)"]={"type":"persistent", "providers": ["\(env.NNS_URL)"]}' "$dfx_file")"
    echo "$contents" >"$dfx_file"

    # Save
    if git status --untracked-files=no --porcelain | grep $dfx_file; then
        git commit -m "Update dfx file at: $dfx_file" "$dfx_file"
    fi
)

step 0.A.4 "Populate canister IDs" || time {
    set_verbosity
    original="$REPO_ROOT/scripts/staging/canisters/canister_ids.json"
    tempfile="$(mktemp)"
    {
        # Include the original:
        cat "$original"
        # Clone the nnstestnet canister IDs, substituting NETWORK for "nnstestnet"
        jq <"$original" '. as $in| keys[] | {(.): {(env.NETWORK):$in[(.)].nnstestnet}}'
        jq <"$original" '. as $in| keys[] | {(.): {"bootstrap_\(env.NETWORK)":$in[(.)].nnstestnet}}'
    } | jq -s 'reduce .[] as $item ({}; . * $item)' >"$tempfile"
    mv "$tempfile" "$original"
}

step 0.B Prepare the shell || true

step 0.B.1 "Set environment variables" || time (
    set_verbosity
    set_verbosity
    test -n "$NETWORK"

    # parent_nns_url is the first ipv6 address in the parent (initially only root) NNS subnet
    parent_nns_host="$(NODES_FILTER_INCLUDE='node_type=root_nns' "$ENV_DIR/hosts" --nns-nodes | head -n1 | awk '{print $2}')"
    # http://[2a00:fb01:400:42:5000:2fff:fe6a:a8ac]:8080
    setvar parent_nns_url "http://[$parent_nns_host]:8080"

    setvar NNS_URL "${parent_nns_url:-}"
)

step 0.B.2.A "Get artifacts" || time (

    set_verbosity

    "${REPO_ROOT_IC}"/gitlab-ci/src/artifacts/rclone_download.py \
        --git-rev="$GIT_REVISION" --out="$results_dir/bin" --remote-path=release --unpack --mark-executable

    "${REPO_ROOT_IC}"/gitlab-ci/src/artifacts/rclone_download.py \
        --git-rev="$GIT_REVISION" --out="$results_dir/artifacts" --remote-path=canisters --unpack

    "${REPO_ROOT_IC}"/gitlab-ci/src/artifacts/rclone_download.py \
        --git-rev="$GIT_REVISION" --out="$results_dir/artifacts" --remote-path=guest-os
)

step 0.B.3 "MacOS only: Avoid Gatekeeper" || time (
    set_verbosity
    [[ "$ARCH" == "x86_64-darwin" ]] || exit 0
    echo
    echo
    echo "MacOS only: On MacOS, downloaded binaries may be blocked by Gatekeeper. If so, run open $BIN_DIR, then right-click on the ic-admin executable and select 'Open', to avoid later assumptions that it is malware."
    echo
    echo
    echo Press ENTER to proceed
    read -r
    echo Opening...
    open "$BIN_DIR"
    echo Press ENTER when you have run ic-admin
    read -r
    echo Thank you.
)

step 0.C.1 "Make sure the local HSM is detected" || time (
    set_verbosity
    echo "Make sure that you have generated a root key per the instructions at: "
    echo "  https://www.notion.so/Instructions-for-the-key-creation-on-the-HSM-devices-85d628774d7b4e729e9163a4619f6bdb"
    pkcs11-tool ${HSM_MODULE:+--module ${HSM_MODULE}} --list-slots | grep -q "HSM" || {
        echo "HSM is not plugged in, or needs to be re-plugged if present."
        exit 1
    }

    HSM_SLOT="${HSM_SLOT:-$(pkcs11-tool --list-slots | sed -nr '/Nitrokey/{s/.*(0x[0-9]+).*/\1/g;ta;b;:a;p;q}')}"

    echo "Verify that the local key is labelled Master"
    # Sadly --list-slots together with --slot doesn't list just the one slot so we get the info for that slot out by regex.
    pkcs11-tool --list-slots | sed -nE "/^Slot\s+[0-9]+\s[(]${HSM_SLOT}[)]/,/^\S/{p}" | sed '${/^\S/d}' | grep -qE 'token label\s+:\sMaster' || {
        printf "WARNING: %s\n" \
            "Slot HSM_SLOT=$HSM_SLOT is not the master slot." \
            "If you have a Master and an IC OPS key you should probably use the master key for consistency."
    }

    echo Verify thet the pin file is defined and exists
    test -e "${HSM_PIN_FILE:-}" || {
        printf "ERROR: %s\n" \
            "File HSM_PIN_FILE = '${HSM_PIN_FILE:-}' not found"
        exit 1
    }
    load_pin

    echo "Verify that the local HSM slot and pin are correct"
    if pkcs11-tool --test --slot "$HSM_SLOT" --pin "$HSM_PIN" >/dev/null; then
        echo OK
    else
        printf "ERROR: %s\n" "HSM ERROR" "HSM vars seem to be incorrect or key '${HSM_KEY_ID:-}' has not been generated."
        exit 1
    fi

    echo "Verify that the local key is present and can be used"
    if pkcs11-tool --sign --id "$HSM_KEY_ID" -i <(echo foo) -o /dev/null --slot "$HSM_SLOT" --pin "$HSM_PIN" >/dev/null; then
        echo OK
    else
        printf "ERROR: %s\n" "HSM ERROR" "Can access slot but cannot sign with the given key ID."
        exit 1
    fi

    setvar HSM_SLOT "$HSM_SLOT"
    setvar HSM_KEY_ID "$HSM_KEY_ID"
    setvar HSM_PIN_FILE "$HSM_PIN_FILE"
)

# Avoid having to call this many times by calling it once here:
load_pin

step 0.C.2 "Make sure that bare-metal hosts have HSMs plugged in" || {
    cd "$ENV_DIR"
    # Run the following command even on physical hosts that do not have VMs on them
    ansible -i "hosts" physical_hosts -m shell -a "lsusb | grep -E 'Nitro|Clay'"
}

# TODO: Verify that the node HSMs correspond to public keys in the list above.

step 0.D.1 "Set DFX credentials" || time (
    set_verbosity
    #  "Run dfx identity list. If the output does not contain alpha2-super-leader, then download the PEM file from the (misnamed) alpha2 registry mutator vault, then move that file to ~/.config/dfx/identity/alpha2-super-leader/identity.pem"
    # Now try dfx identity list again: it should be in the list. This identity will be used to vote on proposals.
    # TODO: How do we know that an existing super-leader key file is the right one?  Is it better to always install the key rather than relying on some unknown state?
    # ^^^ That is now taken care of in step 0.B.4.
    # TODO: get and save super-leader principal ID with:
    # cd canisters ; dfx --identity "$NETWORK-super-leader" identity get-principal
    # TODO: Get and save the SUPER_LEADER_NEURON_INDEX (maybe call it SUPER_LEADER_NEURON_INDEX?) by
    # awk -F';' -vpid="$SUPER_LEADER_PRINCIPAL_ID" '($2==pid){print $1; exit}' $ENV_DIR/initial-neurons.csv
    SUPER_LEADER="${NETWORK}-super-leader"
    test_leadership_skills() {
        dfx identity list | grep -qw "$SUPER_LEADER" || {
            echo Not a super-leader
            return 1
        }
        diff "$SUPER_LEADER_KEY_FILE" "$HOME/.config/dfx/identity/$SUPER_LEADER/identity.pem" || {
            echo Super leader has a different key
            return 1
        }
    }
    improve_leadership_skills() {
        echo Making a SUPER LEADER
        mkdir -p "$HOME/.config/dfx/identity/$SUPER_LEADER"
        cp "$SUPER_LEADER_KEY_FILE" "$HOME/.config/dfx/identity/$SUPER_LEADER/identity.pem"
    }
    improve_leadership_skills && test_leadership_skills
    setvar SUPER_LEADER "$SUPER_LEADER"
)

step 0.D.2 "Verify that the super leader has a neuron" || time (
    set_verbosity
    set -euo pipefail

    PRINCIPAL_NAME="$NETWORK-super-leader"
    PRINCIPAL_ID="$(
        cd "$REPO_ROOT/scripts/staging/canisters"
        dfx --identity "$PRINCIPAL_NAME" identity get-principal || {
            printf "ERROR: %s\n" "No principal: '$PRINCIPAL_NAME'" >&2
            exit 1
        }
    )"

    NEURON_INDEX="$(ic-get-neuron-ids "$ENV_DIR/bootstrap-governance.pb" "$PRINCIPAL_ID")"
    (("$NEURON_INDEX" == 49)) || {
        printf "WARNING: The $PRINCIPAL_NAME has an unexpected neuron index: $NEURON_INDEX" >&2
        exit 1
    }

    setvar SUPER_LEADER_PRINCIPAL_ID "$PRINCIPAL_ID"
    setvar SUPER_LEADER_NEURON_INDEX "$NEURON_INDEX"
)
step 0.D.3 "Set ops DFX credentials" || time (
    set_verbosity
    IC_SUPPORT="${NETWORK}-support"
    test_key() {
        dfx identity list | grep -qw "$IC_SUPPORT" || {
            echo No key by that name: "$IC_SUPPORT"
            return 1
        }
        diff "$IC_SUPPORT_KEY_FILE" "$HOME/.config/dfx/identity/$IC_SUPPORT/identity.pem" || {
            echo Super leader has a different key
            return 1
        }
    }
    install_key() {
        echo Adding a key
        mkdir -p "$HOME/.config/dfx/identity/$IC_SUPPORT"
        cp "$IC_SUPPORT_KEY_FILE" "$HOME/.config/dfx/identity/$IC_SUPPORT/identity.pem"
    }
    install_key && test_key
    setvar IC_SUPPORT "$IC_SUPPORT"
)

step 0.D.4 "Verify that the ic-support key has a neuron" || time (
    set_verbosity

    PRINCIPAL_NAME="$IC_SUPPORT"
    PRINCIPAL_ID="$(
        cd "$REPO_ROOT/scripts/staging/canisters"
        dfx --identity "$PRINCIPAL_NAME" identity get-principal || {
            printf "ERROR: %s\n" "No principal: '$PRINCIPAL_NAME'" >&2
            exit 1
        }
    )"

    NEURON_INDEX_IN_PARENT="$(ic-get-neuron-ids "$ENV_DIR/bootstrap-governance.pb" "$PRINCIPAL_ID")"
    NEURON_INDEX_IN_CHILD="$(ic-get-neuron-ids "$ENV_DIR/initial-governance.pb" "$PRINCIPAL_ID")"
    (("$NEURON_INDEX_IN_PARENT" == 50)) || {
        printf "WARNING: The $PRINCIPAL_NAME has an unexpected neuron index in the parent pb file: $NEURON_INDEX_IN_PARENT" >&2
        exit 1
    }
    (("$NEURON_INDEX_IN_CHILD" == "$NEURON_INDEX_IN_PARENT")) || {
        printf "WARNING: The $PRINCIPAL_NAME has an unexpected neuron index in the parent pb file: $NEURON_INDEX_IN_CHILD" >&2
        exit 1
    }

    setvar IC_SUPPORT_PRINCIPAL_ID "$PRINCIPAL_ID"
    setvar IC_SUPPORT_NEURON_INDEX "$NEURON_INDEX_IN_CHILD"
)

step 0.D.5 "Set root_nns_url variable" || time (
    set_verbosity

    root_nns_host="$(NODES_FILTER_INCLUDE='node_type=root_nns' "$ENV_DIR/hosts" --nns-nodes | head -n1 | awk '{print $2}')"
    setvar root_nns_url "http://[$root_nns_host]:8080"

    setvar NNS_URL "${root_nns_url:-}"
)

step 0.E "Ensure the serial numbers and HSM public keys for the deployment" || time (
    set_verbosity
    set -euo pipefail
    python3 "$REPO_ROOT"/factsdb/main.py --deployment-name $NETWORK \
        --refresh --refresh-hsm-public-keys --update-serial-numbers --update-hsm-public-keys
)

step 0.F "Clear the factsdb" || time (
    set_verbosity
    rm -rf "$REPO_ROOT"/factsdb/data/${NETWORK}_*.csv
)

function root_nns_facts() {
    (
        export NODES_FILTER_INCLUDE='node_type=root_nns'
        guest_facts --refresh | grep 'node_type=root_nns'
    )
}

function root_nns_principals() {
    root_nns_facts | while read line; do
        set -x
        eval entry=$line
        echo $principal
    done
}

function root_nns_ipv6() {
    root_nns_facts | while read line; do
        set -x
        eval entry=$line
        echo "$ipv6"
    done
}

step 1 "Install initial NNS node" || true

step 1.A "Deploy the root NNS node" || time (
    set_verbosity
    export NODES_FILTER_INCLUDE='node_type=root_nns'

    # Verify that nodes do NOT have the lockdown service activated
    ansible -i "$ENV_DIR/hosts" physical_hosts -m shell -a "! systemctl is-active dfinity-lockdown"

    echo "**** Build USB sticks"
    set -x
    MEDIA_PATH="$results_dir/artifacts/media"
    rm -rf "$MEDIA_PATH"
    mkdir -p "$MEDIA_PATH"
    "$ENV_DIR/hosts" --media-json >"$MEDIA_PATH/${NETWORK}.json"
    REPO_ROOT="$REPO_ROOT_IC" "$REPO_ROOT_IC/ic-os/guestos/scripts/build-deployment.sh" \
        --debug \
        --input="$MEDIA_PATH/${NETWORK}.json" \
        --output="$MEDIA_PATH" \
        --git-revision=$GIT_REVISION \
        --whitelist="$ENV_DIR/provisional_whitelist.json" \
        --dkg-interval-length=$DKG_INTERVAL_LENGTH

    cd "$REPO_ROOT_IC/testnet/ansible"

    echo "**** Create new IC instance"
    ansible-playbook roles/ic_guest_prod/playbook.yml -i "$ENV_DIR/hosts" --limit physical_hosts \
        -e ic_git_revision=$GIT_REVISION -e ic_media_path="$MEDIA_PATH" -e ic_state="create"

    echo "**** Start VMs"
    ansible-playbook roles/ic_guest_prod/playbook.yml -i "$ENV_DIR/hosts" --limit physical_hosts -e ic_state=start
)

step 1.B "Install the root NNS canisters" || time (
    set_verbosity
    export NODES_FILTER_INCLUDE='node_type=root_nns'
    MEDIA_PATH="$results_dir/artifacts/media"

    cd "$REPO_ROOT_IC/testnet/ansible"

    echo "**** Install NNS canisters"
    ansible-playbook roles/ic_guest_prod/playbook.yml -i "$ENV_DIR/hosts" --limit physical_hosts -e ic_media_path="$MEDIA_PATH" -e ic_state="install"
)

step 1.C.1 "Check the NNS has been installed by running the get-topology command" || time (
    set_verbosity
    network_file="$(record_network_topology_from_url "$root_nns_url")"

    echo There should be one subnet...
    num_subnets="$(jq <"$network_file" '.topology.subnets | keys | length')"
    expected_num_subnets=1
    ((num_subnets == expected_num_subnets)) || {
        printf "ERROR: %s\n" "NETWORK TOPOLOGY ERROR" "Wrong number of subnets" "Expected: $expected_num_subnets" "Actual:   $num_subnets"
        exit 1
    }
    echo OK

    echo The subnet should have one member
    total_members="$(jq <"$network_file" '.topology.subnets | map(.records) | flatten | map(.value.membership) | flatten | length')"
    expected_num_members=1
    ((total_members == expected_num_members)) || {
        printf "ERROR: %s\n" "NETWORK TOPOLOGY ERROR" "Wrong number of nodes in subnet" "Expected: $expected_num_members" "Actual:   $total_members"
        exit 1
    }
    echo OK

    echo There should be no unassigned nodes
    num_unassigned="$(jq <"$network_file" '.topology.unassigned_nodes | length')"
    expected_num_unassigned=0
    ((num_unassigned == expected_num_unassigned)) || {
        printf "ERROR: %s\n" "NETWORK TOPOLOGY ERROR" "Wrong number of unassigned nodes" "Expected: $expected_num_unassigned" "Actual:   $num_unassigned" \
            "This is a new NNS; the registry should contain nothing but the NNS itself."
        exit 1
    }
    echo OK
)

step 1.C.2 "Get the principal ids" || time (
    network_file="$(record_network_topology_from_url "$root_nns_url")"
    setvar parent_nns_principal "$(jq <"$network_file" -r '.topology.subnets | keys | .[]' | grep .)"
    setvar root_node_principal "$(jq <"$network_file" -r '.topology.subnets | values | map(.records[0].value.membership[0]) | .[]' | grep .)"
)

step 1.D "Update the dfx.json with the root NNS url" || time (
    set_verbosity

    # Set root_nns_url in the env_vars file:
    setvar root_nns_host "$(echo "$(root_nns_ipv6)" | head -n1)"
    setvar root_nns_url "http://[$root_nns_host]:8080"

    # Set the child nns url in dfx.json
    dfx_file="$REPO_ROOT/scripts/staging/canisters/dfx.json"
    contents="$(jq --indent 2 '.networks["\(env.NETWORK)"]={"type":"persistent", "providers": ["\(env.root_nns_url)"]}' "$dfx_file")"
    echo "$contents" >"$dfx_file"
)

step 2 "Add parent NNS nodes" || true

step 2.A "Create configuration media image" || true

step 2.A.1 "Get the root NNS public key" || (
    ic-admin --nns-url "${root_nns_url}" get-subnet-public-key 0 "$results_dir/nns_public_key.pem"

    test -r "$results_dir/nns_public_key.pem" # file exists
    test -s "$results_dir/nns_public_key.pem" # file is not empty
)

step 2.A.2 "Add the Node Provider (NP) and Node Operators (NO) into the registry" || (
    set -eux

    function add_node_provider() {
        principal=$(cat "$1")
        ic-admin --nns-url "$root_nns_url" \
            --secret-key-pem ~/.config/dfx/identity/bootstrap-super-leader/identity.pem \
            propose-to-add-or-remove-node-provider add --node-provider-pid "${principal}" \
            --proposer 49 --summary "Add node providers"
        ic-admin --nns-url "$root_nns_url" \
            --secret-key-pem ~/.config/dfx/identity/bootstrap-super-leader/identity.pem \
            propose-to-add-node-operator "$principal" \
            --proposer 49 --summary "Add node operator" --node-operator-principal-id "$principal" --node-allowance 64
    }
    export -f add_node_provider

    # Submit up to 32 NNS proposals at the time
    ls $ENV_DIR/data_centers/*.principal | xargs -n1 -P32 -I'{}' bash -c "add_node_provider {}"
)

step 2.B "Create the config media image" || (
    set -eux
    cd "$REPO_ROOT_IC/ic-os/guestos/"
    mkdir -p "$results_dir/config"
    for node in $(NODES_FILTER_INCLUDE='node_type=parent_nns' "$ENV_DIR/hosts" --nodes | cut -d: -f1); do
        hostname=$(echo $node | sed 's/[^a-z0-9]\+/-/g')
        rm -f "$results_dir/config/$node.img"
        ./scripts/build-bootstrap-config-image.sh \
            $results_dir/config/$node.img \
            --accounts_ssh_authorized_keys "$ENV_DIR/ssh_keys_dfinity_nodes/" \
            --nns_url $root_nns_url \
            --nns_public_key $results_dir/nns_public_key.pem \
            --hostname $hostname
    done
)

step 2.C "Create parent nns guest domains" || time (
    cd "${REPO_ROOT_IC}/testnet/ansible"
    set -x
    NODES_FILTER_INCLUDE='node_type=parent_nns' ansible-playbook roles/ic_guest_prod/playbook.yml \
        -i "$ENV_DIR/hosts" --limit physical_hosts \
        -e ic_git_revision=$GIT_REVISION \
        -e ic_media_path="$results_dir/config" \
        -e ic_state="create"
)

step 2.D Start guest domains || time (
    cd "${REPO_ROOT_IC}/testnet/ansible"
    set -x
    # Verify that nodes do NOT have the lockdown service activated
    NODES_FILTER_INCLUDE='node_type=parent_nns' ansible -i "$ENV_DIR/hosts" physical_hosts \
        -m shell -a "! systemctl is-active dfinity-lockdown"
    # Start
    NODES_FILTER_INCLUDE='node_type=parent_nns' ansible-playbook roles/ic_guest_prod/playbook.yml \
        -i "$ENV_DIR/hosts" --limit physical_hosts -e ic_state=start
)

step 2.E "Verify that parent nns nodes are registered in the NNS as unassigned" || time (

    set_verbosity
    # Query the NNS for the list of nodes pending joining, by running the get-topology command, and check that all nodes listed in the hosts file in subnet_1 are registered as unassigned nodes.

    network_file="$(record_network_topology_from_url "$root_nns_url")"
    join_pending="${results_dir}/${STEP}.join_pending"
    export NODES_FILTER_INCLUDE='node_type=(root|parent)_nns'
    echo
    echo "Waiting can be boring.  Follow the action on the NNS:"
    echo "    NODES_FILTER_INCLUDE='node_type=root_nns' ansible -i $ENV_DIR/hosts -a 'journalctl -n1000 -xu ic-replica.service' nns"
    echo "And on all nodes:"
    echo "    NODES_FILTER_INCLUDE='node_type=(root|parent)_nns' ansible -i $ENV_DIR/hosts -a 'journalctl -n10 -u ic-replica.service' nodes"
    echo "And the topology, which is where we are waiting for the new nodes to appear:"
    echo "    watch -d cat '$network_file'"
    echo
    echo "File with nodes pending the network join: ${join_pending}"
    echo
    echo "Live topology information:"
    echo "    ic-admin --nns-url \"$root_nns_url\" get-topology"

    for ((retries = 1000; ; retries--)); do
        new_nodes=$(guest_facts --refresh | grep -E 'node_type=parent_nns' || true)
        num_not_joined="$(echo "$new_nodes" | grep -vE 'principal=[a-zA-Z0-9]' | tee "${join_pending}" | wc -l || true)"
        # Report on progress, and loop if not all nodes have registered.
        printf "\r Waiting for %3d/%3d nodes to appear in the topology. Retries left: %3d " "$num_not_joined" "$(echo "$new_nodes" | wc -l)" "$retries"
        if ((num_not_joined == 0)); then
            printf "\nOK\n"
            break
        elif ((retries > 0)); then
            sleep 1
        else
            printf "ERROR: %s\n" \
                "REGISTRATION ERROR All registered nodes should have principals. These don't:" >&2
            echo "$new_nodes" >&2
            exit 1
        fi
    done
)

step 3 "Extend the Parent NNS" || true

function non_root_parent_nns_facts() {
    export NODES_FILTER_INCLUDE='node_type=parent_nns'
    guest_facts | grep 'node_type=parent_nns'
}

function non_root_parent_nns_principals() {
    non_root_parent_nns_facts | while read line; do
        eval entry=$line
        echo $principal
    done
}

function non_root_parent_nns_ipv6() {
    non_root_parent_nns_facts | while read line; do
        eval entry=$line
        echo "$ipv6"
    done
}

step 3.A Add nodes to the NNS || time (
    set_verbosity
    principals=$(non_root_parent_nns_principals)
    set -x
    ic-admin --nns-url "$root_nns_url" --secret-key-pem ~/.config/dfx/identity/bootstrap-super-leader/identity.pem propose-to-add-nodes-to-subnet --proposer 49 --subnet 0 $principals
)

step 3.B "Check NNS was extended successfully" || time (
    set_verbosity

    set -x
    topology_file="$(record_network_topology_from_url "$root_nns_url")"
    num_nodes_in_the_subnet="$(jq <"$topology_file" '.topology.subnets|map(.records[0].value.membership)|.[]|length' | tail -n 1)"
    # Count how many should have joined the root node.
    # Do not expect those that failed to register to be included, although if they have come up in the meantime that is cool.
    # We do match both the _lockout and the non-lockout nodes.
    num_non_root_parent_nodes="$(non_root_parent_nns_principals | wc -l)"
    ((${num_nodes_in_the_subnet:-0} == 1 + ${num_non_root_parent_nodes:-0}))
)

step 3.C "Wait until the newly added parent NNS nodes are up and running" || time (
    set_verbosity
    function all_ok() {
        for ipv6 in $(non_root_parent_nns_ipv6); do
            if is_live_ipv6 "$ipv6"; then
                echo "The address http://[$ipv6]:8080/_/dashboard is up"
            else
                echo "The address $ipv6 is not up yet."
                return 1
            fi
        done
        return 0
    }
    for ((retries = 100; ; retries--)); do
        echo "Tries left: $retries"
        if all_ok 2>/dev/null; then
            echo "All OK"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            echo "ERROR: Timeout waiting for parent_nns_hosts to come up"
            exit 1
        fi
    done
)

step 3.D.1 "Set parent_nns_url variable" || time (
    set_verbosity

    parent_nns_host="$(NODES_FILTER_INCLUDE='node_type=parent_nns' "$ENV_DIR/hosts" --nns-nodes | head -n1 | awk '{print $2}')"
    setvar parent_nns_url "http://[$parent_nns_host]:8080"

    setvar NNS_URL "${parent_nns_url:-}"
)

step 3.D.2 "Populate dfx.json" || time (
    set_verbosity

    dfx_file="$REPO_ROOT/scripts/staging/canisters/dfx.json"

    contents="$(jq --indent 2 '.networks["\(env.NETWORK)"]={"type":"persistent", "providers": ["\(env.parent_nns_url)"]}' "$dfx_file")"
    echo "$contents" >"$dfx_file"
)

step --optional 3.E "Update the service discovery so that stats are available on grafana" || time (
    set_verbosity
    cd "${REPO_ROOT_IC}/testnet/ansible"
    NODES_FILTER_INCLUDE='node_type=(root|parent)_nns' \
        ansible-playbook -i "$ENV_DIR/hosts" ic_p8s_network_update.yml \
        -e yes_i_confirm=yes -e ic_git_revision=$GIT_REVISION
    NODES_FILTER_INCLUDE='node_type=(root|parent)_nns' \
        ansible-playbook -i "$ENV_DIR/hosts" ic_p8s_service_discovery_install.yml \
        -e yes_i_confirm=yes -e ic_git_revision=$GIT_REVISION
)

step 4 "Create child NNS" || true

function child_nns_facts() {
    export NODES_FILTER_INCLUDE='node_type=child_nns'
    guest_facts --refresh | grep -E 'node_type=child_nns'
}

function child_nns_principals() {
    child_nns_facts | while read line; do
        eval entry=$line
        echo $principal
    done
}

function child_nns_ipv6() {
    child_nns_facts | while read line; do
        eval entry=$line
        echo "$ipv6"
    done
}

step 4.A "Create the config media image" || (
    set -eux
    cd "$REPO_ROOT_IC/ic-os/guestos/"
    mkdir -p "$results_dir/config"
    for node in $(NODES_FILTER_INCLUDE='node_type=child_nns' "$ENV_DIR/hosts" --nodes | cut -d: -f1); do
        hostname=$(echo $node | sed 's/[^a-z0-9]\+/-/g')
        rm -f "$results_dir/config/$node.img"
        ./scripts/build-bootstrap-config-image.sh \
            $results_dir/config/$node.img \
            --accounts_ssh_authorized_keys "$ENV_DIR/ssh_keys_dfinity_nodes/" \
            --nns_url $parent_nns_url \
            --nns_public_key $results_dir/nns_public_key.pem \
            --hostname $hostname
    done
)

step 4.B "Create child nns guest domains" || time (
    cd "${REPO_ROOT_IC}/testnet/ansible"
    set -x
    NODES_FILTER_INCLUDE='node_type=child_nns' ansible-playbook roles/ic_guest_prod/playbook.yml \
        -i "$ENV_DIR/hosts" --limit physical_hosts \
        -e ic_git_revision=$GIT_REVISION \
        -e ic_media_path="$results_dir/config" \
        -e ic_state="create"
)

step 4.C Start guest domains || time (
    cd "${REPO_ROOT_IC}/testnet/ansible"
    set -x
    # Verify that nodes do NOT have the lockdown service activated
    NODES_FILTER_INCLUDE='node_type=child_nns' ansible -i "$ENV_DIR/hosts" physical_hosts \
        -m shell -a "! systemctl is-active dfinity-lockdown"
    # Start
    NODES_FILTER_INCLUDE='node_type=child_nns' ansible-playbook roles/ic_guest_prod/playbook.yml \
        -i "$ENV_DIR/hosts" --limit physical_hosts -e ic_state=start
)

step 4.D "Verify that child nns nodes are registered in the NNS as unassigned" || time (

    set_verbosity
    # Query the NNS for the list of nodes pending joining, by running the get-topology command, and check that all nodes listed in the hosts file in subnet_1 are registered as unassigned nodes.

    export NODES_FILTER_INCLUDE='node_type=(root|parent|child)_nns'
    network_file="$(record_network_topology_from_url "$parent_nns_url" || true)"
    join_pending="${results_dir}/${STEP}.join_pending"
    echo
    echo "Waiting can be boring.  Follow the action on the NNS:"
    echo "    NODES_FILTER_INCLUDE='node_type=parent_nns' ansible -i $ENV_DIR/hosts -a 'journalctl -n1000 -xu ic-replica.service' nns"
    echo "And on all nodes:"
    echo "    NODES_FILTER_INCLUDE='node_type=(parent|child)_nns' ansible -i $ENV_DIR/hosts -a 'journalctl -n10 -u ic-replica.service' nodes"
    echo "And the topology, which is where we are waiting for the new nodes to appear:"
    echo "    watch -d cat '$network_file'"
    echo
    echo "File with nodes pending the network join: ${join_pending}"
    echo
    echo "Live topology information:"
    echo "    ic-admin --nns-url \"$parent_nns_url\" get-topology"

    for ((retries = 1000; ; retries--)); do
        network_file="$(record_network_topology_from_url "$parent_nns_url" || {
            echo "Refreshing topology failed"
            sleep 5
            continue
        })"
        new_nodes=$(guest_facts --refresh | grep -E 'node_type=child_nns' || {
            echo "Refreshing guest facts failed"
            sleep 5
            continue
        })
        num_not_joined="$(echo "$new_nodes" | grep -vE 'principal=[a-zA-Z0-9]' | tee "${join_pending}" | wc -l || true)"
        # Report on progress, and loop if not all nodes have registered.
        printf "\r Waiting for %3d/%3d nodes to appear in the topology. Retries left: %3d " "$num_not_joined" "$(echo "$new_nodes" | wc -l)" "$retries"
        if ((num_not_joined == 0)); then
            printf "\nOK\n"
            break
        elif ((retries > 0)); then
            sleep 1
        else
            printf "ERROR: %s\n" \
                "REGISTRATION ERROR All registered nodes should have principals. These don't:" >&2
            echo "$new_nodes" >&2
            exit 1
        fi
    done
)

step 4.E "Create the child NNS subnet" || time (
    set_verbosity
    set -o pipefail
    # Get child_nns nodes that have managed to register.
    NEW_NODE_IDS=($(child_nns_principals))
    # NEW_NODE_IDS is meant to expand to multiple arguments
    # shellcheck disable=SC2086
    PROPOSAL_TO_CREATE_PARENT_SUBNET="$(
        #--test-neuron-proposer \
        set -x
        ic-admin \
            -s "$SUPER_LEADER_KEY_FILE" \
            --nns-url "${parent_nns_url}" \
            propose-to-create-subnet \
            --subnet-handler-id "unused" \
            --dkg-interval-length 99 \
            --subnet-type system \
            --proposer "${SUPER_LEADER_NEURON_INDEX}" \
            --replica-version-id "${GIT_REVISION}" \
            --start-as-nns \
            "${NEW_NODE_IDS[@]}" \
            | tee /dev/stderr | sed -nr '${s/^proposal\s+([0-9]+)$/\1/;ta;b;:a;p}' | grep .
    )"
    setvar PROPOSAL_TO_CREATE_PARENT_SUBNET "$PROPOSAL_TO_CREATE_PARENT_SUBNET"
)

step 4.F "Verify that votes have gone in" || time (
    wait_for_proposal_approval "$NETWORK" "$PROPOSAL_TO_CREATE_PARENT_SUBNET"
)

step 4.G "Verify that the proposal has been scheduled for execution" || time (
    wait_for_proposal_execution "$NETWORK" "$PROPOSAL_TO_CREATE_PARENT_SUBNET"
)

step 4.H "Get the child NNS principal id" || time (
    set_verbosity
    echo "Check if the new subnet was created by running the following command and see if the IDs were added to the subnet"

    network_file="$(record_network_topology_from_url "$parent_nns_url")"
    ((1 == "$(jq <"$network_file" -r '.topology.subnets|keys|.[]' | grep -v "$parent_nns_principal" | wc -l)")) || {
        printf "ERROR: Expected one subnet apart from the parent NNS\n" >&2
        exit 1
    }
    setvar child_nns_principal "$(jq <"$network_file" -r '.topology.subnets|keys|.[]' | grep -v "$parent_nns_principal")"
    test -n "${child_nns_principal:-}" || {
        printf "ERROR: %s\n" "Child NNS not set."
    }
    echo OK
)

step 4.I "Check that the child NNS nodes are listening on port 8080" || time {
    set_verbosity
    function all_ok() {
        for ipv6 in $(child_nns_ipv6); do
            if is_live_ipv6 "$ipv6"; then
                echo "The address http://[$ipv6]:8080/_/dashboard is up"
            else
                echo "The address $ipv6 is not up yet."
                return 1
            fi
        done
        return 0
    }
    for ((retries = 100; ; retries--)); do
        echo "Tries left: $retries"
        if all_ok 2>/dev/null; then
            echo "All OK"
            break
        elif ((retries > 0)); then
            sleep 10
        else
            echo "ERROR: Timeout waiting for parent_nns_hosts to come up"
            exit 1
        fi
    done
}

step 5 "Install NNS canisters on child NNS (HSM required)" || true

step 5.A.1 NNS canister install prepare config.tgz || time (
    set_verbosity
    cd "${REPO_ROOT_IC}/testnet/ansible"
    MEDIA_PATH="$results_dir/artifacts/media"

    # We need to take the ic_registry_local_store from the child NNS
    CHILD_NNS_IPV6=$(echo "$(child_nns_ipv6)" | head -n1)
    child_nns_node0=$(child_nns_facts | cut -d' ' -f1 | head -n1)
    mkdir -p "$MEDIA_PATH/tmp/$child_nns_node0"
    set -x
    rsync -ac --delete -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" \
        "admin@[$CHILD_NNS_IPV6]":/var/lib/ic/data/ic_registry_local_store/ \
        "$MEDIA_PATH/tmp/$child_nns_node0/ic_registry_local_store/"
    set +x
    rm -f "$MEDIA_PATH/config.tgz"
    tar czf "$MEDIA_PATH/config.tgz" -C "$MEDIA_PATH/tmp" .
    rm -rf "$MEDIA_PATH/tmp"
)

step 5.A.2 NNS canister install || time (
    set_verbosity
    cd "${REPO_ROOT_IC}/testnet/ansible"
    MEDIA_PATH="$results_dir/artifacts/media"
    # Install the child NNS canisters
    set -x
    NODES_FILTER_INCLUDE='node_type=child_nns' ansible-playbook roles/ic_guest_prod/playbook.yml \
        -i "$ENV_DIR/hosts" --limit physical_hosts \
        -e ic_git_revision=$GIT_REVISION \
        -e ic_media_path="$MEDIA_PATH" \
        -e ic_state="install"
)

step 5.B Verify || time (
    set_verbosity
    num_running_subnet_2_canisters_preinstall=0
    child_nns_node0_ipv6=$(echo "$(child_nns_ipv6)" | head -n1)
    num_running_canisters="$(curl "http://[$child_nns_node0_ipv6]:9090" | awk '/replicated_state_registered_canisters{status="running"}/{print $2}')"
    ((num_running_canisters > num_running_subnet_2_canisters_preinstall)) || {
        printf "ERROR: %s\n" \
            "Expected to have more running canisters now than before" \
            "Num canisters before installing canisters:  ${num_running_subnet_2_canisters_preinstall}" \
            "Num canisters now:                          ${num_running_canisters}"
        exit 1
    }
    echo "OK: Have ${num_running_canisters} running canisters.  ($num_running_subnet_2_canisters_preinstall before)"
)

step 5.C "Update the dfx.json with the child NNS url" || time (
    set_verbosity
    set -eEuo pipefail

    CHILD_IPV6=$(child_nns_ipv6)
    # Set child_nns_url in the env_vars file:
    setvar child_nns_host "$(echo "$CHILD_IPV6" | head -n1)"
    setvar child_nns_url "http://[$child_nns_host]:8080"

    setvar NNS_URL "${child_nns_url:-}"

    # Set the child nns url in dfx.json
    dfx_file="$REPO_ROOT/scripts/staging/canisters/dfx.json"
    contents="$(jq --indent 2 '.networks["\(env.NETWORK)"]={"type":"persistent", "providers": ["\(env.child_nns_url)"]}' "$dfx_file")"
    echo "$contents" >"$dfx_file"
    echo "Updated $dfx_file"
)

function app_nodes_facts() {
    if [[ $# -gt 0 ]]; then
        guest_facts --refresh | grep -E "node_type=$1"
    else
        guest_facts --refresh | grep -E 'node_type=app_[0-9]+'
    fi
}

function app_nodes_principals() {
    local FACTS=$(app_nodes_facts "$@")
    echo "$FACTS" | while read line; do
        eval entry=$line
        echo $principal
    done
}

function app_nodes_ipv6() {
    local FACTS=$(app_nodes_facts "$@")
    echo "$FACTS" | while read line; do
        eval entry=$line
        echo "$ipv6"
    done
}

step 6 "Create an application subnet" || true

step 6.A "Update the Prometheus configuration" || time (
    set_verbosity

    cd "${REPO_ROOT_IC}/testnet/ansible"
    MEDIA_PATH="$results_dir/artifacts/media"
    export NODES_FILTER_INCLUDE='node_type=(child_nns|app_[0-9]+)'
    ansible-playbook -i "$ENV_DIR/hosts" ic_p8s_network_update.yml \
        -e yes_i_confirm=yes -e ic_media_path="$MEDIA_PATH" -e ic_git_revision=$GIT_REVISION
    ansible-playbook -i "$ENV_DIR/hosts" ic_p8s_service_discovery_install.yml \
        -e yes_i_confirm=yes -e ic_media_path="$MEDIA_PATH" -e ic_git_revision=$GIT_REVISION
)

step 6.B "Get the child NNS public key" || (
    ic-admin --nns-url "${child_nns_url}" get-subnet-public-key 0 "$results_dir/child_nns_public_key.pem"

    test -r "$results_dir/child_nns_public_key.pem" # file exists
    test -s "$results_dir/child_nns_public_key.pem" # file is not empty
)

step 6.C "Create the config media image" || (
    set -eux
    cd "$REPO_ROOT_IC/ic-os/guestos/"
    mkdir -p "$results_dir/config"
    for node in $(NODES_FILTER_INCLUDE='node_type=app_[0-9]+' "$ENV_DIR/hosts" --nodes | cut -d: -f1); do
        hostname=$(echo $node | sed 's/[^a-z0-9]\+/-/g')
        rm -f "$results_dir/config/$node.img"
        ./scripts/build-bootstrap-config-image.sh \
            $results_dir/config/$node.img \
            --accounts_ssh_authorized_keys "$ENV_DIR/ssh_keys_dfinity_nodes/" \
            --nns_url $child_nns_url \
            --nns_public_key $results_dir/child_nns_public_key.pem \
            --hostname $hostname
    done
)

step 6.D "Create the VM domains" || time (
    cd "${REPO_ROOT_IC}/testnet/ansible"
    set -x
    NODES_FILTER_INCLUDE='node_type=app_[0-9]+' ansible-playbook roles/ic_guest_prod/playbook.yml \
        -i "$ENV_DIR/hosts" --limit physical_hosts \
        -e ic_git_revision=$GIT_REVISION \
        -e ic_media_path="$results_dir/config" \
        -e ic_state="create"
)

step 6.E "Start the VM domains" || time (
    cd "${REPO_ROOT_IC}/testnet/ansible"
    set -x
    # Verify that nodes do NOT have the lockdown service activated
    NODES_FILTER_INCLUDE='node_type=app_[0-9]+' ansible -i "$ENV_DIR/hosts" physical_hosts \
        -m shell \
        -a "systemctl is-active dfinity-lockdown || true"
    # Start
    NODES_FILTER_INCLUDE='node_type=app_[0-9]+' ansible-playbook roles/ic_guest_prod/playbook.yml \
        -i "$ENV_DIR/hosts" --limit physical_hosts -e ic_state=start
)

step 6.F "Verify that new nodes are registered in the NNS as unassigned" || time (
    set_verbosity
    # Query the NNS for the list of nodes pending joining, by running the get-topology command, and check that all nodes listed in the hosts file in subnet_1 are registered as unassigned nodes.

    network_file="$(record_network_topology_from_url "$child_nns_url")"
    join_pending="${results_dir}/${STEP}.join_pending"
    echo
    echo "Waiting can be boring.  Follow the action on the NNS:"
    echo "    NODES_FILTER_INCLUDE='node_type=child_nns' ansible -i $ENV_DIR/hosts -a 'journalctl -n1000 -xu ic-replica.service' nns"
    echo "And application nodes:"
    echo "    NODES_FILTER_INCLUDE='node_type=app_[0-9]+' ansible -i $ENV_DIR/hosts -a 'journalctl -n10 -u ic-replica.service' nodes"
    echo "And the topology, which is where we are waiting for the new nodes to appear:"
    echo "    watch -d cat '$network_file'"
    echo
    echo "File with nodes pending the network join: ${join_pending}"
    echo
    echo "Live topology information:"
    echo "    ic-admin --nns-url "$child_nns_url" get-topology"

    for ((retries = 1000; ; retries--)); do
        network_file="$(record_network_topology_from_url "$child_nns_url")"
        new_nodes=$(guest_facts --refresh | grep -E 'node_type=app_[0-9]+' || {
            echo "Refreshing guest facts failed"
            sleep 5
            continue
        })
        num_not_joined="$(echo "$new_nodes" | grep -vE 'principal=[a-zA-Z0-9]' | tee "${join_pending}" | wc -l || true)"
        # Report on progress, and loop if not all nodes have registered.
        printf "\r Waiting for %3d/%3d nodes to appear in the topology. Retries left: %3d " "$num_not_joined" "$(echo "$new_nodes" | wc -l)" "$retries"
        if ((num_not_joined == 0)); then
            printf "\nOK\n"
            break
        elif ((retries > 0)); then
            sleep 1
        else
            printf "ERROR: %s\n" \
                "REGISTRATION ERROR All registered nodes should have principals. These don't:" >&2
            echo "$new_nodes" >&2
            exit 1
        fi
    done
)

step 6.G.1 "app_1: Create an application subnet" || time (
    set_verbosity
    set -o pipefail
    app_nodes_principals app_1
    # Get child_nns nodes that have managed to register.
    NEW_NODE_IDS=($(app_nodes_principals app_1))
    # NEW_NODE_IDS is meant to expand to multiple arguments
    # shellcheck disable=SC2086
    PROPOSAL_TO_CREATE_APP_SUBNET="$(
        #--test-neuron-proposer \
        set -x
        ic-admin \
            -s "$SUPER_LEADER_KEY_FILE" \
            --nns-url "${child_nns_url}" \
            propose-to-create-subnet \
            --subnet-handler-id "unused" \
            --subnet-type application \
            --proposer "${SUPER_LEADER_NEURON_INDEX}" \
            --replica-version-id "${GIT_REVISION}" \
            "${NEW_NODE_IDS[@]}" \
            | tee /dev/stderr | sed -nr '${s/^proposal\s+([0-9]+)$/\1/;ta;b;:a;p}' | grep .
    )"
    setvar PROPOSAL_TO_CREATE_SUBNET_APP_1 "$PROPOSAL_TO_CREATE_APP_SUBNET"
)

step 6.G.2 "app_2: Create an application subnet" || time (
    set_verbosity
    set -o pipefail
    app_nodes_principals app_2
    # Get child_nns nodes that have managed to register.
    NEW_NODE_IDS=($(app_nodes_principals app_2))
    # NEW_NODE_IDS is meant to expand to multiple arguments
    # shellcheck disable=SC2086
    PROPOSAL_TO_CREATE_APP_SUBNET="$(
        #--test-neuron-proposer \
        set -x
        ic-admin \
            -s "$SUPER_LEADER_KEY_FILE" \
            --nns-url "${child_nns_url}" \
            propose-to-create-subnet \
            --subnet-handler-id "unused" \
            --subnet-type application \
            --proposer "${SUPER_LEADER_NEURON_INDEX}" \
            --replica-version-id "${GIT_REVISION}" \
            "${NEW_NODE_IDS[@]}" \
            | tee /dev/stderr | sed -nr '${s/^proposal\s+([0-9]+)$/\1/;ta;b;:a;p}' | grep .
    )"
    setvar PROPOSAL_TO_CREATE_SUBNET_APP_2 "$PROPOSAL_TO_CREATE_APP_SUBNET"
)

step 6.H.1 "app_1: Verify that votes have gone in" || time (
    wait_for_proposal_approval "$NETWORK" "$PROPOSAL_TO_CREATE_SUBNET_APP_1"
)

step 6.H.2 "app_2: Verify that votes have gone in" || time (
    wait_for_proposal_approval "$NETWORK" "$PROPOSAL_TO_CREATE_SUBNET_APP_2"
)

step 6.H.3 "app_1: Verify that the proposal has been scheduled for execution" || time (
    wait_for_proposal_execution "$NETWORK" "$PROPOSAL_TO_CREATE_SUBNET_APP_1"
)

step 6.H.4 "app_2: Verify that the proposal has been scheduled for execution" || time (
    wait_for_proposal_execution "$NETWORK" "$PROPOSAL_TO_CREATE_SUBNET_APP_2"
)

step 6.I "Update guest facts" || time (
    set_verbosity
    set -euo pipefail

    # Refresh the factsdb
    export NODES_FILTER_INCLUDE='node_type=(child_nns|app_[0-9]+)'
    "${REPO_ROOT}/factsdb/main.py" --deployment-name $NETWORK --refresh
)

step 6.P "Update prometheus targets" || time (
    set -x
    curl -v --insecure -X DELETE -H "Content-Type: application/json" https://ic-service-discovery.ch1-obsstage1.dfinity.network/service-discovery/staging

    sleep 5
    NNS_PUBLIC_KEY_STRING=$(cat "$results_dir/child_nns_public_key.pem" | sed '/^-----.*/d' | tr -d '\r\n')

    curl -v --fail --insecure -X POST -H "Content-Type: application/json" -d '{"ic_name": "staging", "nns_urls": "'${child_nns_url}'", "nns_public_key": "'$NNS_PUBLIC_KEY_STRING'"}' https://ic-service-discovery.ch1-obsstage1.dfinity.network/service-discovery
)

echo
finaltime="$(date '+%s')"
duration=$((finaltime - starttime))
echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed in total in this test."
echo "SUCCESS: bootstrap.sh executed with the following arguments: $@"

test -z "${STEPS:-}" || ((NUM_STEPS_MATCHED)) || {
    printf "ERROR: %s\n" \
        "NO STEPS MATCHED THE PATTERN '$STEPS'"
}
